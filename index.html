<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ãƒãƒˆãƒ«</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            overscroll-behavior: none;
        }
        .card {
            border: 1px solid #ccc; border-radius: 8px; padding: 4px; margin: 4px;
            width: 110px; height: 160px; display: flex; flex-direction: column;
            background-color: white; box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 0.7rem; position: relative;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 4px 4px 10px rgba(0,0,0,0.2); }
        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 2px; padding: 2px 4px;
        }
        .card-name { font-weight: bold; font-size: 0.75rem; flex-grow: 1; text-align: left; }
        .card-type { font-size: 0.6rem; color: #555; text-align: right; margin-left: 4px; }
        .card-cost {
            position: absolute; top: 2px; right: 2px; background-color: gold; color: black;
            border-radius: 50%; width: 22px; height: 22px; display: flex;
            align-items: center; justify-content: center; font-size: 0.7rem;
            font-weight: bold; border: 1px solid #b8860b; z-index: 10;
        }
        .card-image-placeholder {
            width: calc(100% - 8px); height: 70px; background-color: #e0e0e0;
            margin: 0 auto 4px auto; display: flex; align-items: center; justify-content: center;
            font-size: 0.65rem; color: #777; border-radius: 4px;
        }
        .card-image-placeholder img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .card-stats {
            display: flex; justify-content: space-around; font-size: 0.7rem;
            margin-top: 2px; padding: 0 4px; font-weight: bold;
        }
        .card-description {
            font-size: 0.6rem; margin-top: 2px; height: 38px; overflow-y: auto;
            border-top: 1px solid #eee; padding: 4px; line-height: 1.2;
        }
        .unit-card.can-attack { border: 2px solid limegreen; }
        .unit-card.has-attacked { border: 2px solid orange; }
        .unit-card.selected-for-action { /* General selection highlight */
            outline: 3px solid dodgerblue !important;
            box-shadow: 0 0 10px dodgerblue;
        }
        .unit-card.blocker-candidate { outline: 3px solid cyan !important; }


        .field-zone {
            border: 2px dashed #aaa; min-height: 170px; display: flex; flex-wrap: wrap;
            align-items: flex-start; justify-content: center;
            padding: 20px 10px 10px 10px;
            margin-bottom:10px; background-color: rgba(0, 128, 0, 0.05);
            position: relative; border-radius: 8px;
        }
        .field-zone-label {
            position: absolute; top: 2px; right: 5px; font-size: 0.7rem; color: #666;
            background-color: rgba(255,255,255,0.7); padding: 1px 4px; border-radius: 3px;
        }
        .hand-zone {
            border: 2px dashed #66f; min-height: 170px; display: flex; flex-wrap: wrap;
            align-items: flex-start; justify-content: center; padding: 10px;
            background-color: rgba(100, 100, 255, 0.05); border-radius: 8px;
        }
        .player-area {
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px;
            border-radius: 8px; background-color: #f9f9f9;
        }
        .player-area.active-player { border-color: gold; box-shadow: 0 0 10px gold; }
        .player-area.blocking-player { border-color: cyan; box-shadow: 0 0 10px cyan; }
        .log-area {
            height: 150px; border: 1px solid #ccc; overflow-y: scroll;
            padding: 10px; margin-top: 20px; background-color: #f0f0f0;
            border-radius: 4px;
        }
        .action-button {
            padding: 8px 12px; margin: 5px; border-radius: 6px;
            cursor: pointer; font-weight: bold; transition: background-color 0.2s ease;
        }
        .targetable { outline: 3px solid red !important; cursor: crosshair; }
        .trap-card-set {
            background-color: purple; color: white; display: flex; align-items: center;
            justify-content: center; text-align: center;
        }
        .trap-card-set .card-header, .trap-card-set .card-image-placeholder,
        .trap-card-set .card-stats, .trap-card-set .card-description { display: none; }
        .trap-card-set::before { content: "SET TRAP"; color: white; font-weight: bold; font-size: 0.9rem; }
        .trap-card-set .card-cost { display: none; }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff; padding: 20px; border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); text-align: left;
            max-width: 90%; max-height: 90vh; overflow-y: auto;
        }
        
        #cardDetailModalContent {
            display: flex; width: 450px; max-width: 90%; padding: 15px;
        }
        .card-detail-image-column { flex: 0 0 150px; margin-right: 15px; display: flex; align-items: center; justify-content: center; }
        .card-detail-image-column img { max-width: 100%; max-height: 220px; border-radius: 8px; border: 1px solid #ccc; }
        .card-detail-info-column { flex: 1; display: flex; flex-direction: column; }
        .card-detail-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .card-detail-name { font-size: 1.2rem; font-weight: bold; margin-right: 10px; }
        .card-detail-type { font-size: 0.9rem; color: #555; }
        .card-detail-cost { font-size: 1rem; font-weight: bold; color: #8B4513; margin-bottom: 8px; }
        .card-detail-stats { font-size: 0.9rem; margin-bottom: 8px; }
        .card-detail-description {
            font-size: 0.85rem; line-height: 1.4; background-color: #f9f9f9; padding: 8px;
            border-radius: 4px; min-height: 60px; overflow-y: auto; flex-grow: 1;
        }
        #cardDetailModal .cancel-button { margin-top: 15px; float: right; }

        #summonConfirmModalContent { width: 300px; text-align: center; }
        #summonCardDisplay { margin-bottom: 15px; display: flex; justify-content: center;}
        .summon-button {
            background-color: #28a745; color: white; padding: 10px 15px;
            border: none; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .summon-button:disabled { background-color: #ccc; cursor: not-allowed; }
        .cancel-button {
            background-color: #6c757d; color: white; padding: 10px 15px;
            border: none; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .cancel-button:hover { background-color: #5a6268; }

        #blockSelectModalContent { width: 500px; text-align: center; }
        #blockInfo { margin-bottom: 15px; }
        #blockerSelectionArea { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 15px; min-height: 100px;}
        .block-button {
            background-color: #007bff; color: white; padding: 10px 15px;
            border: none; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .block-button:hover { background-color: #0056b3; }


        #battleLogOverlay {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8); color: white;
            padding: 15px 25px; border-radius: 8px; z-index: 2000;
            font-size: 1.1rem; text-align: center;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        .core-display span { display: inline-block; margin-right: 2px; font-size: 1.2rem; }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto max-w-6xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-700">ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ãƒãƒˆãƒ«</h1>
        
        <!-- ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤é–‹å§‹ãƒœã‚¿ãƒ³ -->
        <div class="text-center mb-4">
            <button id="multiplayerButton" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤
            </button>
        </div>

        <!-- ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="multiplayerModal" class="modal-overlay">
            <div class="modal-content w-full max-w-md">
                <h2 class="text-xl font-bold mb-4">ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
                
                <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åè¨­å®š -->
                <div class="mb-4">
                    <label for="playerNameInput" class="block mb-2 text-sm font-medium">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å:</label>
                    <input type="text" id="playerNameInput" class="w-full p-2 border rounded" placeholder="åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">
                </div>

                <!-- ã‚µãƒ¼ãƒãƒ¼URLè¨­å®š -->
                <div class="mb-4">
                    <label for="serverUrlInput" class="block mb-2 text-sm font-medium">ã‚µãƒ¼ãƒãƒ¼URL:</label>
                    <input type="text" id="serverUrlInput" class="w-full p-2 border rounded" value="ws://localhost:3000" placeholder="ws://localhost:3000">
                </div>
                
                <!-- æ¥ç¶šçŠ¶æ…‹ -->
                <div id="connectionStatus" class="mb-4 text-sm text-gray-600">æœªæ¥ç¶š</div>
                
                <div class="flex space-x-4 mb-4">
                    <!-- æ¥ç¶šãƒœã‚¿ãƒ³ -->
                    <button id="connectButton" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex-1">
                        ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š
                    </button>
                    
                    <!-- åˆ‡æ–­ãƒœã‚¿ãƒ³ -->
                    <button id="disconnectButton" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded flex-1" disabled>
                        åˆ‡æ–­
                    </button>
                </div>
                
                <div class="border-t border-gray-200 my-4 pt-4">
                    <!-- éƒ¨å±‹ä½œæˆ -->
                    <div class="mb-4">
                        <label for="roomNameInput" class="block mb-2 text-sm font-medium">éƒ¨å±‹å:</label>
                        <input type="text" id="roomNameInput" class="w-full p-2 border rounded" placeholder="éƒ¨å±‹åã‚’å…¥åŠ›">
                        <button id="createRoomButton" class="mt-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full" disabled>
                            éƒ¨å±‹ã‚’ä½œæˆ
                        </button>
                    </div>
                    
                    <!-- éƒ¨å±‹ä¸€è¦§ -->
                    <div class="mb-4">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-lg font-medium">éƒ¨å±‹ä¸€è¦§</h3>
                            <button id="refreshRoomsButton" class="text-sm bg-gray-200 hover:bg-gray-300 py-1 px-2 rounded" disabled>
                                æ›´æ–°
                            </button>
                        </div>
                        <div id="roomsList" class="border rounded p-2 max-h-40 overflow-y-auto bg-gray-50">
                            <div class="text-sm text-gray-500 italic">ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¦ãã ã•ã„</div>
                        </div>
                    </div>
                </div>
                
                <button id="closeMultiplayerModal" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded w-full mt-4">
                    é–‰ã˜ã‚‹
                </button>
            </div>
        </div>

        <div id="player2-area" class="player-area mb-4">
            <div class="flex justify-between items-center mb-2">
                <h2 id="player2-name" class="text-xl font-semibold text-gray-600">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</h2>
                <div>
                    <span class="mr-4">LP: <span id="player2-lp" class="font-bold">10000</span></span>
                    <span>ã‚³ã‚¢: <span id="player2-core" class="font-bold core-display"></span></span>
                </div>
            </div>
            <div class="text-sm mb-2">æ‰‹æœ­: <span id="player2-hand-count">0</span>æš | ãƒ‡ãƒƒã‚­: <span id="player2-deck-count">20</span>æš | æ¨ã¦æœ­: <span id="player2-discard-count">0</span>æš</div>
            <div id="player2-hand" class="hand-zone bg-gray-200 p-2 rounded min-h-[170px] flex flex-wrap justify-center items-start"></div>
            <div class="grid grid-cols-1 md:grid-cols-7 gap-2 mt-2">
                <div id="player2-field-units" class="md:col-span-5 field-zone bg-green-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">ãƒ¦ãƒ‹ãƒƒãƒˆã‚¾ãƒ¼ãƒ³</span></div>
                <div id="player2-field-trap" class="md:col-span-1 field-zone bg-purple-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">ãƒˆãƒ©ãƒƒãƒ—</span></div>
                <div id="player2-field-resource" class="md:col-span-1 field-zone bg-yellow-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">ãƒªã‚½ãƒ¼ã‚¹</span></div>
            </div>
        </div>

        <div class="text-center my-4 p-3 bg-white shadow rounded">
            <p class="text-lg font-semibold">ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³: <span id="current-turn-player" class="text-blue-600">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</span></p>
            <p class="text-lg">ãƒ•ã‚§ãƒ¼ã‚º: <span id="current-phase" class="text-green-600">ã‚²ãƒ¼ãƒ æº–å‚™ä¸­</span> (<span id="sub-phase" class="text-orange-500"></span>)</p>
            <div id="action-buttons" class="mt-2"></div>
            <div id="attack-action-area" class="mt-2"></div> </div>

        <div id="player1-area" class="player-area mt-4">
             <div class="flex justify-between items-center mb-2">
                <h2 id="player1-name" class="text-xl font-semibold text-gray-600">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</h2>
                <div>
                    <span class="mr-4">LP: <span id="player1-lp" class="font-bold">10000</span></span>
                    <span>ã‚³ã‚¢: <span id="player1-core" class="font-bold core-display"></span></span>
                </div>
            </div>
            <div class="text-sm mb-2">æ‰‹æœ­: <span id="player1-hand-count">0</span>æš | ãƒ‡ãƒƒã‚­: <span id="player1-deck-count">20</span>æš | æ¨ã¦æœ­: <span id="player1-discard-count">0</span>æš</div>
            <div class="grid grid-cols-1 md:grid-cols-7 gap-2 mb-2">
                <div id="player1-field-units" class="md:col-span-5 field-zone bg-green-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">ãƒ¦ãƒ‹ãƒƒãƒˆã‚¾ãƒ¼ãƒ³</span></div>
                <div id="player1-field-trap" class="md:col-span-1 field-zone bg-purple-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">ãƒˆãƒ©ãƒƒãƒ—</span></div>
                 <div id="player1-field-resource" class="md:col-span-1 field-zone bg-yellow-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">ãƒªã‚½ãƒ¼ã‚¹</span></div>
            </div>
            <div id="player1-hand" class="hand-zone bg-blue-100 p-2 rounded min-h-[170px] flex flex-wrap justify-center items-start"></div>
        </div>

        <div class="mt-6">
            <h3 class="text-lg font-semibold text-gray-700 mb-2">ã‚²ãƒ¼ãƒ ãƒ­ã‚°</h3>
            <div id="game-log" class="log-area bg-white p-3 rounded shadow h-40 overflow-y-auto"><p>ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™...</p></div>
        </div>
    </div>

    <div id="cardDetailModal" class="modal-overlay">
        <div id="cardDetailModalContent" class="modal-content"></div>
    </div>

    <div id="summonConfirmModal" class="modal-overlay">
        <div id="summonConfirmModalContent" class="modal-content">
            <p class="text-lg font-semibold mb-3">ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å¬å–šã—ã¾ã™ã‹ï¼Ÿ</p>
            <div id="summonCardDisplay" class="flex justify-center"></div>
            <div id="summonActionButtons" class="mt-4">
                <button id="confirmSummonButton" class="summon-button">å¬å–šã™ã‚‹</button>
                <button id="cancelSummonButton" class="cancel-button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>

    <div id="blockSelectModal" class="modal-overlay">
        <div id="blockSelectModalContent" class="modal-content">
            <h3 class="text-xl font-semibold mb-3">ãƒ–ãƒ­ãƒƒã‚¯é¸æŠ</h3>
            <div id="blockInfo" class="mb-4"></div>
            <p class="mb-2">ãƒ–ãƒ­ãƒƒã‚¯ã«ä½¿ç”¨ã™ã‚‹è‡ªåˆ†ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆä»»æ„ï¼‰ï¼š</p>
            <div id="blockerSelectionArea" class="border p-2 rounded mb-4 min-h-[120px]">
                </div>
            <button id="confirmBlockButton" class="block-button">é¸æŠã—ãŸãƒ¦ãƒ‹ãƒƒãƒˆã§ãƒ–ãƒ­ãƒƒã‚¯</button>
            <button id="noBlockButton" class="cancel-button">ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„</button>
        </div>
    </div>

    <!-- ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤é–¢é€£ã®ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="multiplayerModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <h2 class="text-xl font-bold mb-4">ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤</h2>
            
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åè¨­å®š -->
            <div class="mb-4">
                <label for="playerNameInput" class="block text-sm font-medium mb-1">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åï¼š</label>
                <div class="flex">
                    <input type="text" id="playerNameInput" class="border rounded p-2 flex-grow mr-2" placeholder="åå‰ã‚’å…¥åŠ›">
                    <button id="setPlayerNameButton" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">è¨­å®š</button>
                </div>
            </div>
            
            <!-- ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
            <div id="multiplayerMenu" class="flex flex-col gap-2">
                <button id="createRoomButton" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">éƒ¨å±‹ã‚’ä½œæˆ</button>
                <button id="joinRoomButton" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">éƒ¨å±‹ä¸€è¦§ã‚’è¡¨ç¤º</button>
                <button id="closeMultiplayerButton" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded mt-2">é–‰ã˜ã‚‹</button>
            </div>
            
            <!-- éƒ¨å±‹ä½œæˆç”»é¢ -->
            <div id="createRoomSection" class="hidden flex-col gap-2">
                <label for="roomNameInput" class="block text-sm font-medium mb-1">éƒ¨å±‹ã®åå‰ï¼š</label>
                <input type="text" id="roomNameInput" class="border rounded p-2 mb-2" placeholder="éƒ¨å±‹ã®åå‰ã‚’å…¥åŠ›">
                <button id="confirmCreateRoomButton" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">ä½œæˆã™ã‚‹</button>
                <button id="backFromCreateButton" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded mt-2">æˆ»ã‚‹</button>
            </div>
            
            <!-- éƒ¨å±‹ä¸€è¦§ç”»é¢ -->
            <div id="roomListSection" class="hidden flex-col">
                <h3 class="text-lg font-semibold mb-2">éƒ¨å±‹ä¸€è¦§</h3>
                <div id="roomListContainer" class="border rounded p-2 max-h-60 overflow-y-auto mb-2">
                    <p class="text-gray-500">èª­ã¿è¾¼ã¿ä¸­...</p>
                </div>
                <button id="refreshRoomListButton" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">æ›´æ–°</button>
                <button id="backFromRoomListButton" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded mt-2">æˆ»ã‚‹</button>
            </div>
            
            <!-- å¾…æ©Ÿç”»é¢ -->
            <div id="waitingRoomSection" class="hidden flex-col">
                <h3 class="text-lg font-semibold mb-2">å¯¾æˆ¦ç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™</h3>
                <p>éƒ¨å±‹å: <span id="waitingRoomName"></span></p>
                <p class="mt-2">å¯¾æˆ¦ç›¸æ‰‹ãŒå‚åŠ ã™ã‚‹ã®ã‚’å¾…ã£ã¦ã„ã¾ã™...</p>
                <button id="cancelWaitingButton" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded mt-4">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>

    <!-- æ¥ç¶šçŠ¶æ…‹è¡¨ç¤º -->
    <div id="connectionStatus" class="fixed top-2 right-2 bg-gray-200 px-3 py-1 rounded-full text-sm hidden">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-gray-500" id="connectionIndicator"></span>
        <span id="connectionText">æœªæ¥ç¶š</span>
    </div>

    <div id="battleLogOverlay"></div>
    <div id="messageModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <p id="modalMessageText"></p>
            <button id="modalCloseButton" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mt-3">OK</button>
        </div>
    </div>

    <script>
        const MAX_HAND_SIZE = 7; const INITIAL_LP = 10000; const INITIAL_CORE = 5; const MAX_CORE = 10; const MAX_RECOVERY_CORE = 8;
        const CORE_PER_TURN = 3; const DECK_OUT_DAMAGE = 1000; const MAX_UNITS_ON_FIELD = 5;
        const CARD_PLACEHOLDER_IMAGE_URL = "https://placehold.co/130x180/e0e0e0/777?text=IMG";
        const GEM_EMOJI = 'ğŸ’';

        const cardPool = [
            { id: "unit001", name: "ã‚´ãƒ–ãƒªãƒ³", type: "unit", cost: 1, attack: 500, health: 600, effects: [], description: "ã‹å¼±ã„ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€‚ã ãŒã€ä¾®ã‚‹ã¨ç—›ã„ç›®ã‚’è¦‹ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚é›†å›£ã§è¥²ã„æ›ã‹ã‚‹ã“ã¨ã‚’å¾—æ„ã¨ã™ã‚‹ã€‚", illust_url: "https://placehold.co/100x70/a9a9a9/ffffff?text=Goblin" },
            { id: "unit002", name: "ã‚ªãƒ¼ã‚¯", type: "unit", cost: 3, attack: 800, health: 900, effects: [], description: "å°‘ã—ã‚¿ãƒ•ãªãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€‚åŠ›è‡ªæ…¢ã ãŒã€é ­ã¯ã‚ã¾ã‚Šè‰¯ããªã„ã‚ˆã†ã ã€‚", illust_url: "https://placehold.co/100x70/8b4513/ffffff?text=Orc" },
            { id: "unit003", name: "ãƒŠã‚¤ãƒˆ", type: "unit", cost: 4, attack: 700, health: 1200, effects: [{ type: "keyword", name: "æŒ‘ç™º" }], description: "ã€æŒ‘ç™ºã€‘å‘³æ–¹ã‚’å®ˆã‚‹é¨å£«ã€‚ãã®å …ã„é§ã¯ä»²é–“ãŸã¡ã®ç›¾ã¨ãªã‚‹ã€‚", illust_url: "https://placehold.co/100x70/c0c0c0/000000?text=Knight" },
            { id: "unit004", name: "ã‚°ãƒªãƒ•ã‚©ãƒ³", type: "unit", cost: 5, attack: 1000, health: 800, effects: [{ type: "keyword", name: "é£›è¡Œ" }], description: "ã€é£›è¡Œã€‘ç©ºã‚’èˆã†çŒ›ç¦½ã€‚åœ°ä¸Šã‹ã‚‰ã®æ”»æ’ƒã‚’å—ã‘ä»˜ã‘ãªã„ã€‚", illust_url: "https://placehold.co/100x70/ffd700/000000?text=Griffin" },
            { id: "unit005", name: "ã‚¹ãƒ‘ã‚¤ãƒ€ãƒ¼", type: "unit", cost: 2, attack: 400, health: 400, effects: [{ type: "keyword", name: "æ¯’" }], description: "ã€æ¯’ã€‘å™›ã¾ã‚Œã‚‹ã¨å±é™ºã€‚ãã®ç‰™ã«ã¯å¼·åŠ›ãªæ¯’ãŒä»•è¾¼ã¾ã‚Œã¦ã„ã‚‹ã€‚", illust_url: "https://placehold.co/100x70/006400/ffffff?text=Spider" },
            { id: "unit006", name: "ç–¾é¢¨ã®å‚­å…µ", type: "unit", cost: 2, attack: 700, health: 500, effects: [{ type: "keyword", name: "é€Ÿæ”»" }], description: "ã€é€Ÿæ”»ã€‘ç´ æ—©ã„æ”»æ’ƒã€‚æˆ¦å ´ã«å‡ºã‚‹ã¨åŒæ™‚ã«è¥²ã„æ›ã‹ã‚‹ã€‚", illust_url: "https://placehold.co/100x70/add8e6/000000?text=Mercenary" },
            { id: "unit007", name: "ã‚¨ãƒ«ãƒ•ã®å°„æ‰‹", type: "unit", cost: 3, attack: 600, health: 600, effects: [{ type: "onPlay", action: "damageUnit", value: 500, target: "opponentUnit" }], description: "ã€å ´ã«å‡ºãŸæ™‚ã€‘ç›¸æ‰‹ãƒ¦ãƒ‹ãƒƒãƒˆ1ä½“ã«500ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚æ£®ã®å¥¥æ·±ãã‹ã‚‰æ­£ç¢ºç„¡æ¯”ãªä¸€çŸ¢ã‚’æ”¾ã¤ã€‚", illust_url: "https://placehold.co/100x70/90ee90/000000?text=Archer" },
            { id: "unit008", name: "è³¢è€…", type: "unit", cost: 4, attack: 300, health: 800, effects: [{ type: "onPlay", action: "draw", value: 1 }], description: "ã€å ´ã«å‡ºãŸæ™‚ã€‘ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã€‚å¤ã®çŸ¥è­˜ã¯æ–°ãŸãªæˆ¦ç•¥ã‚’æˆã‘ã‚‹ã€‚", illust_url: "https://placehold.co/100x70/87ceeb/000000?text=Sage" },
            { id: "trap001", name: "è½ã¨ã—ç©´", type: "trap", cost: 2, effects: [{ type: "onOpponentAttackDeclaration", action: "destroyUnit", target: "attackingUnit" }], description: "ç›¸æ‰‹ãƒ¦ãƒ‹ãƒƒãƒˆãŒæ”»æ’ƒå®£è¨€ã—ãŸæ™‚ã€ãã®æ”»æ’ƒãƒ¦ãƒ‹ãƒƒãƒˆã‚’ç ´å£Šã™ã‚‹ã€‚å·§å¦™ã«éš ã•ã‚ŒãŸç½ ãŒæ•µã‚’è‘¬ã‚‹ã€‚", illust_url: "https://placehold.co/100x70/800080/ffffff?text=Pitfall" },
            { id: "trap002", name: "é­”æ³•åå°„", type: "trap", cost: 1, effects: [{ type: "onOpponentSpellPlay", action: "negateSpell" }], description: "ç›¸æ‰‹ãŒå‘ªæ–‡ã‚«ãƒ¼ãƒ‰ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸæ™‚ã€ãã‚Œã‚’ç„¡åŠ¹ã«ã™ã‚‹ã€‚(ç°¡ç•¥åŒ–) é­”åŠ›ã‚’å¼¾ãç¥ç§˜ã®é¡ã€‚", illust_url: "https://placehold.co/100x70/4b0082/ffffff?text=Reflect" },
            { id: "resource001", name: "åŠ›ã®æº", type: "resource", cost: 3, effects: [{ type: "continuous", phase: "start", action: "addCore", value: 1 }], description: "è‡ªåˆ†ã®ã‚¹ã‚¿ãƒ¼ãƒˆãƒ•ã‚§ã‚¤ã‚ºé–‹å§‹æ™‚ã€è¿½åŠ ã§1ã‚³ã‚¢ã‚’å¾—ã‚‹ã€‚å°½ãã‚‹ã“ã¨ã®ãªã„é­”åŠ›ã®æ³‰ã€‚", illust_url: "https://placehold.co/100x70/ffff00/000000?text=PowerSource" },
            { id: "resource002", name: "çŸ¥è­˜ã®æ³‰", type: "resource", cost: 4, effects: [{ type: "continuous", phase: "draw", action: "draw", value: 1 }], description: "è‡ªåˆ†ã®ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºæ™‚ã€è¿½åŠ ã§ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã€‚å¡æ™ºã¯å‹åˆ©ã¸ã®éµã¨ãªã‚‹ã€‚", illust_url: "https://placehold.co/100x70/00ffff/000000?text=WisdomWell" },
        ];

        let players = [];
        let currentPlayerIndex = 0;
        let turnCount = 0;
        let gamePhase = "setup";
        let subPhaseEl = document.getElementById('sub-phase');
        let selectedPlayerCardUUID = null; 
        let selectedOwnerPlayerId = null;  
        let attackActionPending = false; 
        let attackTargetSelected = false; 
        let effectTargetSelected = false;
        let currentEffectAction = null;
        let cardToSummon = null;
        let summonerPlayerId = null;
        let currentAttackerInfo = null;
        let currentAttackTargetInfo = null;
        let selectedBlockerUUID = null;

        const player1NameEl = document.getElementById('player1-name');
        const player1LpEl = document.getElementById('player1-lp');
        const player1CoreEl = document.getElementById('player1-core');
        const player1HandEl = document.getElementById('player1-hand');
        const player1HandCountEl = document.getElementById('player1-hand-count');
        const player1DeckCountEl = document.getElementById('player1-deck-count');
        const player1DiscardCountEl = document.getElementById('player1-discard-count');
        const player1FieldUnitsEl = document.getElementById('player1-field-units');
        const player1FieldTrapEl = document.getElementById('player1-field-trap');
        const player1FieldResourceEl = document.getElementById('player1-field-resource');
        const player2NameEl = document.getElementById('player2-name');
        const player2LpEl = document.getElementById('player2-lp');
        const player2CoreEl = document.getElementById('player2-core');
        const player2HandEl = document.getElementById('player2-hand');
        const player2HandCountEl = document.getElementById('player2-hand-count');
        const player2DeckCountEl = document.getElementById('player2-deck-count');
        const player2DiscardCountEl = document.getElementById('player2-discard-count');
        const player2FieldUnitsEl = document.getElementById('player2-field-units');
        const player2FieldTrapEl = document.getElementById('player2-field-trap');
        const player2FieldResourceEl = document.getElementById('player2-field-resource');
        const currentTurnPlayerEl = document.getElementById('current-turn-player');
        const currentPhaseEl = document.getElementById('current-phase');
        const actionButtonsEl = document.getElementById('action-buttons');
        const attackActionAreaEl = document.getElementById('attack-action-area'); 
        const gameLogEl = document.getElementById('game-log');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const cardDetailModalEl = document.getElementById('cardDetailModal');
        const cardDetailModalContentEl = document.getElementById('cardDetailModalContent');
        const summonConfirmModal = document.getElementById('summonConfirmModal');
        const summonCardDisplay = document.getElementById('summonCardDisplay');
        const confirmSummonButton = document.getElementById('confirmSummonButton');
        const cancelSummonButton = document.getElementById('cancelSummonButton');
        const battleLogOverlay = document.getElementById('battleLogOverlay');
        const blockSelectModal = document.getElementById('blockSelectModal');
        const blockInfoEl = document.getElementById('blockInfo');
        const blockerSelectionAreaEl = document.getElementById('blockerSelectionArea');
        const confirmBlockButton = document.getElementById('confirmBlockButton');
        const noBlockButton = document.getElementById('noBlockButton');

        modalCloseButton.onclick = () => { messageModal.style.display = "none"; };
        cancelSummonButton.onclick = () => { summonConfirmModal.style.display = "none"; cardToSummon = null; summonerPlayerId = null; };
        confirmSummonButton.onclick = () => {
            if (cardToSummon && summonerPlayerId) actuallyPlayCard(cardToSummon, summonerPlayerId);
            summonConfirmModal.style.display = "none"; cardToSummon = null; summonerPlayerId = null;
        };
        [messageModal, cardDetailModalEl, summonConfirmModal, blockSelectModal].forEach(modal => {
            modal.onclick = (event) => {
                if (event.target === modal) {
                    modal.style.display = "none";
                    if (modal === summonConfirmModal) { cardToSummon = null; summonerPlayerId = null; }
                    if (modal === blockSelectModal) { resetBlockSelectionState(); changePhase("attack");}
                }
            };
        });
        confirmBlockButton.onclick = () => {
            if (currentAttackerInfo && currentAttackTargetInfo && selectedBlockerUUID) {
                const defenderPlayer = players.find(p => p.id === currentAttackTargetInfo.ownerId || (currentAttackTargetInfo.type === 'player' && p.id === currentAttackTargetInfo.target.id));
                const blockerUnit = defenderPlayer.fieldUnits.find(u => u.uuid === selectedBlockerUUID);
                if (blockerUnit) {
                    logMessage(`${defenderPlayer.name} ã® ${blockerUnit.name} ãŒãƒ–ãƒ­ãƒƒã‚¯ï¼`, true);
                    resolveCombat(currentAttackerInfo.unit, currentAttackerInfo.owner, currentAttackTargetInfo.target, defenderPlayer, blockerUnit);
                } else { 
                     logMessage("ãƒ–ãƒ­ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ï¼šé¸æŠã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚«ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ–ãƒ­ãƒƒã‚¯ãªã—ã¨ã—ã¦å‡¦ç†ã—ã¾ã™ã€‚", true);
                     resolveCombat(currentAttackerInfo.unit, currentAttackerInfo.owner, currentAttackTargetInfo.target, defenderPlayer, null);
                }
            } else if (currentAttackerInfo && currentAttackTargetInfo) { 
                 logMessage("ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã§ã—ãŸã€‚", true);
                 const defenderPlayer = players.find(p => p.id === currentAttackTargetInfo.ownerId || (currentAttackTargetInfo.type === 'player' && p.id === currentAttackTargetInfo.target.id));
                 resolveCombat(currentAttackerInfo.unit, currentAttackerInfo.owner, currentAttackTargetInfo.target, defenderPlayer, null);
            }
            blockSelectModal.style.display = "none";
            resetBlockSelectionState();
            changePhase("attack");
        };
        noBlockButton.onclick = () => {
            logMessage("ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã§ã—ãŸã€‚", true);
            if (currentAttackerInfo && currentAttackTargetInfo) {
                const defenderPlayer = players.find(p => p.id === currentAttackTargetInfo.ownerId || (currentAttackTargetInfo.type === 'player' && p.id === currentAttackTargetInfo.target.id));
                resolveCombat(currentAttackerInfo.unit, currentAttackerInfo.owner, currentAttackTargetInfo.target, defenderPlayer, null);
            }
            blockSelectModal.style.display = "none";
            resetBlockSelectionState();
            changePhase("attack");
        };

        function showMessage(message) { modalMessageText.textContent = message; messageModal.style.display = "flex"; }
        function logMessage(message, isBattleLog = false) {
            const p = document.createElement('p'); p.textContent = message; gameLogEl.appendChild(p);
            gameLogEl.scrollTop = gameLogEl.scrollHeight;
            if (isBattleLog) showBattleLogOverlay(message);
        }
        function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
        function createCardInstance(cardData) {
            const instance = JSON.parse(JSON.stringify(cardData)); instance.uuid = generateUUID();
            if (instance.type === "unit") { instance.currentHealth = instance.health; instance.canAttack = false; instance.hasAttackedThisTurn = false; instance.isResting = false; }
            instance.isSet = false; return instance;
        }
        function showBattleLogOverlay(message) {
            battleLogOverlay.textContent = message; battleLogOverlay.style.display = "block";
            setTimeout(() => { battleLogOverlay.style.display = "none"; }, 1500);
        }
        function showCardDetail(cardData, ownerId) {
            cardDetailModalContentEl.innerHTML = '';
            const imgCol = document.createElement('div'); imgCol.classList.add('card-detail-image-column');
            const img = document.createElement('img'); img.src = cardData.illust_url || CARD_PLACEHOLDER_IMAGE_URL; img.alt = cardData.name;
            imgCol.appendChild(img); cardDetailModalContentEl.appendChild(imgCol);
            const infoCol = document.createElement('div'); infoCol.classList.add('card-detail-info-column');
            const header = document.createElement('div'); header.classList.add('card-detail-header');
            const nameEl = document.createElement('div'); nameEl.classList.add('card-detail-name'); nameEl.textContent = cardData.name;
            header.appendChild(nameEl);
            const typeEl = document.createElement('div'); typeEl.classList.add('card-detail-type'); typeEl.textContent = cardData.type.toUpperCase();
            header.appendChild(typeEl); infoCol.appendChild(header);
            const costEl = document.createElement('div'); costEl.classList.add('card-detail-cost');
            costEl.innerHTML = `ã‚³ã‚¹ãƒˆ: <span style="color: gold;">${GEM_EMOJI.repeat(cardData.cost)}</span> (${cardData.cost})`;
            infoCol.appendChild(costEl);
            if (cardData.type === "unit") {
                const statsEl = document.createElement('div'); statsEl.classList.add('card-detail-stats');
                statsEl.textContent = `æ”»æ’ƒåŠ›: ${cardData.attack} / ä½“åŠ›: ${cardData.currentHealth || cardData.health}`;
                infoCol.appendChild(statsEl);
            }
            const descEl = document.createElement('div'); descEl.classList.add('card-detail-description'); descEl.textContent = cardData.description;
            infoCol.appendChild(descEl);

            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
            const actionButtonsArea = document.createElement('div');
            actionButtonsArea.classList.add('card-detail-action-buttons');
            actionButtonsArea.style.display = 'flex';
            actionButtonsArea.style.justifyContent = 'flex-end';
            actionButtonsArea.style.marginTop = '15px';
            actionButtonsArea.style.gap = '8px';

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç‰¹å®š
            const player = players.find(p => p.id === ownerId);
            const isCurrentPlayer = player && player.isTurnPlayer;
            
            // æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰ã§ã€ãƒ¡ã‚¤ãƒ³ãƒ•ã‚§ã‚¤ã‚ºã®å ´åˆã¯å¬å–š/ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
            if (player && isCurrentPlayer && gamePhase === "main" && player.hand.some(c => c.uuid === cardData.uuid)) {
                const canAfford = player.core >= cardData.cost;
                const hasSpace = cardData.type !== "unit" || player.fieldUnits.length < MAX_UNITS_ON_FIELD;
                const hasTrap = cardData.type === "trap" && player.fieldTrap !== null;
                const hasResource = cardData.type === "resource" && player.fieldResource !== null;
                const canPlay = canAfford && hasSpace && !hasTrap && !hasResource;
                
                const playButton = document.createElement('button');
                playButton.textContent = cardData.type === "unit" ? "å¬å–šã™ã‚‹" : (cardData.type === "trap" ? "ã‚»ãƒƒãƒˆã™ã‚‹" : "ãƒ—ãƒ¬ã‚¤ã™ã‚‹");
                playButton.classList.add(canPlay ? 'summon-button' : 'cancel-button');
                playButton.disabled = !canPlay;
                playButton.style.opacity = canPlay ? '1' : '0.7';
                
                if (!canPlay) {
                    playButton.title = !canAfford ? "ã‚³ã‚¢ãŒè¶³ã‚Šã¾ã›ã‚“" : 
                                      !hasSpace ? "å ´ã«ç©ºããŒã‚ã‚Šã¾ã›ã‚“" : 
                                      (hasTrap || hasResource) ? "æ—¢ã«å ´ã«ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™" : "ãƒ—ãƒ¬ã‚¤ã§ãã¾ã›ã‚“";
                }
                
                playButton.onclick = () => {
                    if (canPlay) {
                        actuallyPlayCard(cardData, ownerId);
                        cardDetailModalEl.style.display = "none";
                    }
                };
                actionButtonsArea.appendChild(playButton);
            }            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¸Šã®ãƒ¦ãƒ‹ãƒƒãƒˆã§ã€æ”»æ’ƒãƒ•ã‚§ã‚¤ã‚ºä¸­ãªã‚‰æ”»æ’ƒãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (player && isCurrentPlayer && gamePhase === "attack" && 
                player.fieldUnits.some(u => u.uuid === cardData.uuid)) {
                const unit = player.fieldUnits.find(u => u.uuid === cardData.uuid);
                if (unit && unit.canAttack && !unit.hasAttackedThisTurn) {
                    const attackButton = document.createElement('button');
                    attackButton.textContent = "æ”»æ’ƒã™ã‚‹";
                    attackButton.classList.add('summon-button');
                    attackButton.style.backgroundColor = '#e74c3c';
                    attackButton.onclick = () => {
                        selectedPlayerCardUUID = unit.uuid;
                        selectedOwnerPlayerId = ownerId;
                        cardDetailModalEl.style.display = "none";
                        
                        // ç›´æ¥ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ”»æ’ƒã¨ã—ã¦å‡¦ç†
                        const attackerPlayer = players.find(p => p.id === ownerId);
                        const defenderPlayer = players.find(p => p.id !== ownerId);
                        if (attackerPlayer && defenderPlayer) {
                            currentAttackerInfo = { 
                                unit: unit, 
                                owner: attackerPlayer 
                            };
                            currentAttackTargetInfo = { 
                                type: 'player', 
                                target: defenderPlayer 
                            };
                            logMessage(`${unit.name} ãŒ ${defenderPlayer.name} ã«æ”»æ’ƒï¼`, true);
                            changePhase("block_declare");
                            promptBlockSelection(unit, defenderPlayer, defenderPlayer);
                        }
                    };
                    actionButtonsArea.appendChild(attackButton);
                }
            }

            const closeButton = document.createElement('button'); 
            closeButton.classList.add('cancel-button'); 
            closeButton.textContent = 'é–‰ã˜ã‚‹';
            closeButton.onclick = () => { 
                cardDetailModalEl.style.display = "none"; 
            };
            actionButtonsArea.appendChild(closeButton);
            infoCol.appendChild(actionButtonsArea);
            
            cardDetailModalContentEl.appendChild(infoCol);
            cardDetailModalEl.style.display = "flex";
        }
        function resetBlockSelectionState() {
            currentAttackerInfo = null; currentAttackTargetInfo = null; selectedBlockerUUID = null;
            document.querySelectorAll('.blocker-candidate').forEach(el => el.classList.remove('blocker-candidate'));
            document.querySelectorAll('.card.selected-for-action').forEach(el => el.classList.remove('selected-for-action')); 
            players.forEach(p => p.playerElements.areaEl.classList.remove('blocking-player'));
            subPhaseEl.textContent = "";
            attackActionAreaEl.innerHTML = ''; 
            attackActionPending = false;
            attackTargetSelected = false;
        }
        
        function initGame() {
            logMessage("ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ã„ã¾ã™...");            players = [
                { id: "player1", name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1", lp: INITIAL_LP, core: INITIAL_CORE, deck: [], hand: [], fieldUnits: [], fieldTrap: null, fieldResource: null, discardPile: [], isTurnPlayer: true, lastTurnCoreUsed: false, coreNotUsedTurns: 0, playerElements: { nameEl: player1NameEl, lpEl: player1LpEl, coreEl: player1CoreEl, handEl: player1HandEl, handCountEl: player1HandCountEl, deckCountEl: player1DeckCountEl, discardCountEl: player1DiscardCountEl, fieldUnitsEl: player1FieldUnitsEl, fieldTrapEl: player1FieldTrapEl, fieldResourceEl: player1FieldResourceEl, areaEl: document.getElementById('player1-area') }},
                { id: "player2", name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2", lp: INITIAL_LP, core: INITIAL_CORE, deck: [], hand: [], fieldUnits: [], fieldTrap: null, fieldResource: null, discardPile: [], isTurnPlayer: false, lastTurnCoreUsed: false, coreNotUsedTurns: 0, playerElements: { nameEl: player2NameEl, lpEl: player2LpEl, coreEl: player2CoreEl, handEl: player2HandEl, handCountEl: player2HandCountEl, deckCountEl: player2DeckCountEl, discardCountEl: player2DiscardCountEl, fieldUnitsEl: player2FieldUnitsEl, fieldTrapEl: player2FieldTrapEl, fieldResourceEl: player2FieldResourceEl, areaEl: document.getElementById('player2-area') }}
            ];
            function buildPlayerDeck() {
                let deck = []; const unitCards = cardPool.filter(c => c.type === 'unit'); const trapCards = cardPool.filter(c => c.type === 'trap'); const resourceCards = cardPool.filter(c => c.type === 'resource');
                for(let i=0; i<14; i++) deck.push(createCardInstance(unitCards[i % unitCards.length]));
                for(let i=0; i<3; i++) deck.push(createCardInstance(trapCards[i % trapCards.length]));
                for(let i=0; i<3; i++) deck.push(createCardInstance(resourceCards[i % resourceCards.length]));
                for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; }
                return deck;
            }
            players.forEach(player => { player.deck = buildPlayerDeck(); for (let i = 0; i < 3; i++) drawCard(player, false); });
            currentPlayerIndex = 0; players[0].isTurnPlayer = true; players[1].isTurnPlayer = false; turnCount = 1;
            resetBlockSelectionState(); clearSelections(); clearEffectSelection(); updateAllUI();
            logMessage(`${players[currentPlayerIndex].name} ã®ã‚¿ãƒ¼ãƒ³ã§ã‚²ãƒ¼ãƒ é–‹å§‹ï¼`);
            changePhase("start");
        }

        function updateAllUI() {
            players.forEach(player => {
                player.playerElements.nameEl.textContent = player.name; player.playerElements.lpEl.textContent = player.lp;
                player.playerElements.coreEl.innerHTML = '';
                for (let i = 0; i < player.core; i++) { const gemSpan = document.createElement('span'); gemSpan.textContent = GEM_EMOJI; player.playerElements.coreEl.appendChild(gemSpan); }
                if (player.core === 0) player.playerElements.coreEl.textContent = '0';
                player.playerElements.handCountEl.textContent = player.hand.length; player.playerElements.deckCountEl.textContent = player.deck.length; player.playerElements.discardCountEl.textContent = player.discardPile.length;
                renderHand(player); renderFieldUnits(player); renderFieldTrap(player); renderFieldResource(player);
                player.playerElements.areaEl.classList.remove('blocking-player');
                if (gamePhase === "block_declare" && player.id === (players[(currentPlayerIndex + 1) % players.length]).id) {
                     player.playerElements.areaEl.classList.add('blocking-player');
                } else if (player.isTurnPlayer) {
                    player.playerElements.areaEl.classList.add('active-player');
                } else {
                    player.playerElements.areaEl.classList.remove('active-player');
                }
            });
            currentTurnPlayerEl.textContent = players[currentPlayerIndex].name; currentPhaseEl.textContent = getPhaseNameJP(gamePhase);
            subPhaseEl.textContent = gamePhase === "block_declare" ? "ãƒ–ãƒ­ãƒƒã‚¯å®£è¨€" : (attackActionPending ? "æ”»æ’ƒæº–å‚™" : (attackTargetSelected ? "æ”»æ’ƒå¯¾è±¡é¸æŠ" : ""));
            updateActionButtons();

            if (attackTargetSelected && selectedPlayerCardUUID) { 
                const player = players.find(p => p.id === selectedOwnerPlayerId);
                if (player) {
                    const opponent = players.find(p => p.id !== player.id);
                    const attackerUnit = player.fieldUnits.find(u => u.uuid === selectedPlayerCardUUID);
                    if (attackerUnit && opponent) highlightTargets(player, opponent, attackerUnit);
                }
            }
        }

        function getPhaseNameJP(phase) {
            switch(phase) {
                case "setup": return "ã‚²ãƒ¼ãƒ æº–å‚™ä¸­"; case "start": return "ã‚¹ã‚¿ãƒ¼ãƒˆãƒ•ã‚§ã‚¤ã‚º"; case "draw": return "ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚º";
                case "main": return "ãƒ¡ã‚¤ãƒ³ãƒ•ã‚§ã‚¤ã‚º"; case "attack": return "æ”»æ’ƒãƒ•ã‚§ã‚¤ã‚º"; case "block_declare": return "æ”»æ’ƒãƒ•ã‚§ã‚¤ã‚º";
                case "end": return "ã‚¨ãƒ³ãƒ‰ãƒ•ã‚§ã‚¤ã‚º"; case "gameOver": return "ã‚²ãƒ¼ãƒ çµ‚äº†"; default: return phase;
            }
        }

        function createCardElement(card, ownerPlayerId, location = "hand") {
            const cardDiv = document.createElement('div'); cardDiv.classList.add('card', `${card.type}-card`);
            cardDiv.dataset.uuid = card.uuid; cardDiv.dataset.owner = ownerPlayerId;
            
            if (card.uuid === selectedPlayerCardUUID && ownerPlayerId === selectedOwnerPlayerId && (attackActionPending || effectTargetSelected || attackTargetSelected)) {
                cardDiv.classList.add('selected-for-action');
            }
            
            if (location === "blockerCandidateDisplay" && card.uuid === selectedBlockerUUID) {
                cardDiv.classList.add('selected-for-action'); 
            }
            const costEl = document.createElement('div'); costEl.classList.add('card-cost'); costEl.textContent = card.cost; cardDiv.appendChild(costEl);
            const headerEl = document.createElement('div'); headerEl.classList.add('card-header');
            const nameEl = document.createElement('div'); nameEl.classList.add('card-name'); nameEl.textContent = card.name; headerEl.appendChild(nameEl);
            const typeEl = document.createElement('div'); typeEl.classList.add('card-type'); typeEl.textContent = card.type.toUpperCase(); headerEl.appendChild(typeEl);
            cardDiv.appendChild(headerEl);
            const imgPlaceholderEl = document.createElement('div'); imgPlaceholderEl.classList.add('card-image-placeholder');
            const imgContent = document.createElement('img'); imgContent.src = card.illust_url; imgContent.alt = card.name;
            imgContent.onerror = () => { imgContent.src = "https://placehold.co/100x70/e0e0e0/777?text=Error"; };
            imgPlaceholderEl.appendChild(imgContent); cardDiv.appendChild(imgPlaceholderEl);
            if (card.type === "unit") {
                const statsEl = document.createElement('div'); statsEl.classList.add('card-stats');
                statsEl.innerHTML = `<span>æ”»:${card.attack}</span><span>ä½“:${card.currentHealth || card.health}</span>`;
                cardDiv.appendChild(statsEl);
                if (card.canAttack && !card.hasAttackedThisTurn) cardDiv.classList.add('can-attack');
                if (card.hasAttackedThisTurn) cardDiv.classList.add('has-attacked');
            }
            const descriptionEl = document.createElement('div'); descriptionEl.classList.add('card-description'); descriptionEl.textContent = card.description;
            cardDiv.appendChild(descriptionEl);
            if (card.type === "trap" && card.isSet) cardDiv.classList.add('trap-card-set');

            if (location !== "detail" && location !== "summon" && location !== "blockerCandidateDisplay") {
                cardDiv.onclick = (e) => {
                    e.stopPropagation();
                    if (gamePhase === "block_declare" && location === "fieldUnit" && ownerPlayerId !== players[currentPlayerIndex].id) {
                        handleBlockerUnitClick(card, ownerPlayerId); 
                    } else {
                        handleCardClick(card, ownerPlayerId, location);
                    }
                };
            } else if (location === "blockerCandidateDisplay") {
                 cardDiv.onclick = (e) => { e.stopPropagation(); handleBlockerUnitClick(card, ownerPlayerId); };
            }
            return cardDiv;
        }
        
        function renderHand(player) {
            player.playerElements.handEl.innerHTML = '';
            if (player.hand.length === 0 && player.id === "player1") player.playerElements.handEl.textContent = "æ‰‹æœ­ãªã—";
            else if (player.hand.length === 0 && player.id === "player2") player.playerElements.handEl.innerHTML = `<div class="text-gray-500 p-4">ç›¸æ‰‹ã®æ‰‹æœ­ãªã—</div>`;
            else player.hand.forEach(card => player.playerElements.handEl.appendChild(createCardElement(card, player.id, "hand")));
        }
        function renderFieldUnits(player) {
            const label = player.playerElements.fieldUnitsEl.querySelector('.field-zone-label');
            player.playerElements.fieldUnitsEl.innerHTML = ''; if (label) player.playerElements.fieldUnitsEl.appendChild(label);
            player.fieldUnits.forEach(unit => {
                const cardEl = createCardElement(unit, player.id, "fieldUnit");
                if (gamePhase === "block_declare" && player.id !== players[currentPlayerIndex].id && unit.uuid === selectedBlockerUUID) {
                    cardEl.classList.add('selected-for-action');
                }
                player.playerElements.fieldUnitsEl.appendChild(cardEl);
            });
        }
        function renderFieldTrap(player) {
            const label = player.playerElements.fieldTrapEl.querySelector('.field-zone-label');
            player.playerElements.fieldTrapEl.innerHTML = ''; if (label) player.playerElements.fieldTrapEl.appendChild(label);
            if (player.fieldTrap) player.playerElements.fieldTrapEl.appendChild(createCardElement(player.fieldTrap, player.id, "fieldTrap"));
        }
        function renderFieldResource(player) {
            const label = player.playerElements.fieldResourceEl.querySelector('.field-zone-label');
            player.playerElements.fieldResourceEl.innerHTML = ''; if (label) player.playerElements.fieldResourceEl.appendChild(label);
            if (player.fieldResource) player.playerElements.fieldResourceEl.appendChild(createCardElement(player.fieldResource, player.id, "fieldResource"));
        }
        function changePhase(newPhase) {
            if (checkWinCondition()) return;
            const oldPhase = gamePhase; gamePhase = newPhase;
            if (oldPhase === "block_declare" && newPhase === "attack") subPhaseEl.textContent = "";
            else logMessage(`${players[currentPlayerIndex].name} - ${getPhaseNameJP(newPhase)}é–‹å§‹`);
            clearSelections();
            if (newPhase !== "block_declare") clearEffectSelection();
            updateAllUI();            switch (newPhase) {
                case "start": handleStartPhase(); break; 
                case "draw": handleDrawPhase(); break;
                case "main": handleMainPhase(); break; 
                case "attack": handleAttackPhaseEntry(); break;
                case "end": handleEndPhase(); break;
            }
        }
          function handleStartPhase() {
            const player = players[currentPlayerIndex];
            if (player.fieldResource) { const resourceEffect = player.fieldResource.effects.find(e => e.type === "continuous" && e.phase === "start"); if (resourceEffect) applyEffect(player.fieldResource, resourceEffect, player, null); }
            
            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ•ã‚§ã‚¤ã‚ºã§ã¯ã‚³ã‚¢å›å¾©ãªã— - ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºã§è¡Œã†
            
            player.lastTurnCoreUsed = false; // æ–°ã—ã„ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«åˆæœŸåŒ–
            player.fieldUnits.forEach(unit => { unit.canAttack = true; unit.hasAttackedThisTurn = false; unit.isResting = false; });
            updateAllUI();
        }        function handleDrawPhase() {
            try {
                const player = players[currentPlayerIndex]; 
                if (!player) {
                    logMessage("ã‚¨ãƒ©ãƒ¼: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", true);
                    return;
                }
                
                // ã‚³ã‚¢å›å¾©ãƒ­ã‚¸ãƒƒã‚¯ï¼šç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã¿ã‚³ã‚¢ã‚’8ã¾ã§å›å¾©
                const coreToAdd = MAX_RECOVERY_CORE - player.core;
                if (coreToAdd > 0) {
                    player.core = MAX_RECOVERY_CORE;
                    logMessage(`${player.name} ã®ã‚³ã‚¢ãŒ ${MAX_RECOVERY_CORE} ã¾ã§å›å¾©ã—ã¾ã—ãŸã€‚`, false);
                }
                
                // ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã
                drawCard(player);
                
                if (player.fieldResource) { 
                    const resourceEffect = player.fieldResource.effects.find(e => e.type === "continuous" && e.phase === "draw"); 
                    if (resourceEffect) applyEffect(player.fieldResource, resourceEffect, player, null); 
                }
                
                // UIã‚’æ›´æ–°ã—ã¦ã‹ã‚‰ãƒ¡ã‚¤ãƒ³ãƒ•ã‚§ã‚¤ã‚ºã«ç§»è¡Œ
                updateAllUI();
                logMessage(`${player.name} ã®ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºå®Œäº†ã€‚ãƒ¡ã‚¤ãƒ³ãƒ•ã‚§ã‚¤ã‚ºã¸ç§»è¡Œã—ã¾ã™ã€‚`);
                
                // å®‰å…¨ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ•ã‚§ã‚¤ã‚ºå¤‰æ›´
                setTimeout(() => {
                    changePhase("main");
                }, 100);
            } catch (error) {
                console.error("ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºå‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
                logMessage("ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚²ãƒ¼ãƒ ã‚’å†é–‹ã—ã¾ã™ã€‚", true);
                gamePhase = "main";
                updateAllUI();
            }
        }
        function drawCard(player, log = true) {
            if (player.deck.length > 0) {
                if (player.hand.length < MAX_HAND_SIZE) { const card = player.deck.pop(); player.hand.push(card); if(log) logMessage(`${player.name} ã¯ã‚«ãƒ¼ãƒ‰ã€Œ${card.name}ã€ã‚’å¼•ã„ãŸã€‚`); }
                else { const card = player.deck.pop(); player.discardPile.push(card); if(log) logMessage(`${player.name} ã¯ã‚«ãƒ¼ãƒ‰ã€Œ${card.name}ã€ã‚’å¼•ã„ãŸãŒæ‰‹æœ­ä¸Šé™ã®ãŸã‚æ¨ã¦æœ­ã¸ã€‚`); }
            } else {
                if(log) logMessage(`${player.name} ã®ãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“ï¼ ${DECK_OUT_DAMAGE} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`, true);
                player.lp -= DECK_OUT_DAMAGE; if (checkWinCondition()) return;
            }
        }
        function handleMainPhase() { logMessage(`${players[currentPlayerIndex].name} ã®ãƒ¡ã‚¤ãƒ³ãƒ•ã‚§ã‚¤ã‚ºã€‚ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`); }
        function handleAttackPhaseEntry() {
            const player = players[currentPlayerIndex];
            const attackableUnits = player.fieldUnits.filter(u => u.canAttack && !u.hasAttackedThisTurn);
            if (attackableUnits.length === 0 && gamePhase === "attack") logMessage("æ”»æ’ƒå¯èƒ½ãªãƒ¦ãƒ‹ãƒƒãƒˆãŒã„ã¾ã›ã‚“ã€‚");
            attackActionAreaEl.innerHTML = ''; 
            attackActionPending = false; 
            attackTargetSelected = false; 
        }        function handleEndPhase() {
            const player = players[currentPlayerIndex];
            if (player.hand.length > MAX_HAND_SIZE) {
                const excessCount = player.hand.length - MAX_HAND_SIZE;
                for (let i = 0; i < excessCount; i++) { const discardedCard = player.hand.shift(); player.discardPile.push(discardedCard); logMessage(`${player.name} ã¯æ‰‹æœ­ä¸Šé™ã‚’è¶…ãˆãŸãŸã‚ ${discardedCard.name} ã‚’æ¨ã¦ãŸã€‚`); }
            }
            player.isTurnPlayer = false; currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            players[currentPlayerIndex].isTurnPlayer = true; turnCount++;
            logMessage(`ã‚¿ãƒ¼ãƒ³çµ‚äº†ã€‚æ¬¡ã¯ ${players[currentPlayerIndex].name} ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`);
            changePhase("start");
        }
        
        // ã‚¿ãƒ¼ãƒ³çµ‚äº†å‡¦ç†é–¢æ•°
        function endTurn() {
            // æ—¢å­˜ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’åˆ©ç”¨ã—ã¦å®Ÿè£…
            changePhase("end");
        }        function updateActionButtons() {
            actionButtonsEl.innerHTML = '';
            if (gamePhase === "gameOver") {
                const restartButton = document.createElement('button'); restartButton.textContent = "ã‚²ãƒ¼ãƒ ã‚’å†é–‹ã™ã‚‹"; restartButton.classList.add('action-button', 'bg-blue-500', 'hover:bg-blue-700', 'text-white');
                restartButton.onclick = () => { gameLogEl.innerHTML = ''; initGame(); }; actionButtonsEl.appendChild(restartButton); return;
            }
            
            // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‹ã¤è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã§ã¯ãªã„å ´åˆã¯ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ãªã„
            if (isMultiplayerMode && players[currentPlayerIndex].id !== "player1") {
                actionButtonsEl.innerHTML = `<p class="text-yellow-600 font-semibold">${players[currentPlayerIndex].name} ã®ã‚¿ãƒ¼ãƒ³ä¸­ã§ã™ã€‚è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã«ãªã‚‹ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚</p>`;
                return;
            }
            
            if (gamePhase === "block_declare" || attackActionPending || attackTargetSelected) { 
                if (gamePhase === "block_declare") actionButtonsEl.innerHTML = `<p class="text-cyan-600 font-semibold">${players[(currentPlayerIndex + 1) % players.length].name} ãŒãƒ–ãƒ­ãƒƒã‚¯ã‚’é¸æŠä¸­ã§ã™...</p>`;
                return;
            }
            switch (gamePhase) {
                case "start": const toDrawButton = document.createElement('button'); toDrawButton.textContent = "ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ã‚¤ã‚ºã¸"; toDrawButton.classList.add('action-button', 'bg-green-500', 'hover:bg-green-700', 'text-white'); toDrawButton.onclick = () => changePhase("draw"); actionButtonsEl.appendChild(toDrawButton); break;
                case "main":
                    const toAttackButton = document.createElement('button'); toAttackButton.textContent = "æ”»æ’ƒãƒ•ã‚§ã‚¤ã‚ºã¸"; toAttackButton.classList.add('action-button', 'bg-red-500', 'hover:bg-red-700', 'text-white'); toAttackButton.onclick = () => changePhase("attack"); actionButtonsEl.appendChild(toAttackButton);
                    const toEndButtonFromMain = document.createElement('button'); toEndButtonFromMain.textContent = "ã‚¿ãƒ¼ãƒ³çµ‚äº†"; toEndButtonFromMain.classList.add('action-button', 'bg-gray-500', 'hover:bg-gray-700', 'text-white'); toEndButtonFromMain.onclick = () => changePhase("end"); actionButtonsEl.appendChild(toEndButtonFromMain); break;
                case "attack":
                    const toEndButtonFromAttack = document.createElement('button'); toEndButtonFromAttack.textContent = "æ”»æ’ƒçµ‚äº† (ãƒ¡ã‚¤ãƒ³ã¸)"; toEndButtonFromAttack.classList.add('action-button', 'bg-blue-500', 'hover:bg-blue-700', 'text-white'); toEndButtonFromAttack.onclick = () => { logMessage("æ”»æ’ƒãƒ•ã‚§ã‚¤ã‚ºã‚’çµ‚äº†ã—ã€ãƒ¡ã‚¤ãƒ³ãƒ•ã‚§ã‚¤ã‚ºã«æˆ»ã‚Šã¾ã™ã€‚"); resetBlockSelectionState(); changePhase("main"); }; actionButtonsEl.appendChild(toEndButtonFromAttack);
                    const directToEndButton = document.createElement('button'); directToEndButton.textContent = "ã‚¿ãƒ¼ãƒ³çµ‚äº†"; directToEndButton.classList.add('action-button', 'bg-gray-500', 'hover:bg-gray-700', 'text-white'); directToEndButton.onclick = () => { resetBlockSelectionState(); changePhase("end");}; actionButtonsEl.appendChild(directToEndButton); break;
            }
        }        function handleCardClick(card, ownerPlayerId, location) {
            showCardDetail(card, ownerPlayerId);
            const player = players.find(p => p.id === ownerPlayerId); 
            if (!player) return;
            
            // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            if (isMultiplayerMode) {
                const currentPlayer = players[currentPlayerIndex];
                
                // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ä»¥å¤–ã§ã‚«ãƒ¼ãƒ‰æ“ä½œã‚’åˆ¶é™ï¼ˆãƒ–ãƒ­ãƒƒã‚¯é¸æŠæ™‚ã¯é™¤ãï¼‰
                if (gamePhase !== "block_declare" && currentPlayer.id !== "player1") {
                    logMessage("ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ä¸­ã¯æ“ä½œã§ãã¾ã›ã‚“", true);
                    return;
                }
                
                // ãƒ–ãƒ­ãƒƒã‚¯é¸æŠæ™‚ã¯ã€ãƒ–ãƒ­ãƒƒã‚«ãƒ¼å´ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã¿æ“ä½œå¯èƒ½
                if (gamePhase === "block_declare" && player.id !== (players[(currentPlayerIndex + 1) % players.length]).id) {
                    // ãƒ–ãƒ­ãƒƒã‚¯é¸æŠä¸­ã¯ã€ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã¨ãªã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ãŒæ“ä½œå¯èƒ½
                    if (player.id === "player1") {
                        logMessage("ç¾åœ¨ã¯ãƒ–ãƒ­ãƒƒã‚¯é¸æŠä¸­ã§ã™ã€‚ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã¨ãªã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„", true);
                    }
                    return;
                }
            }
        }        function actuallyPlayCard(cardToPlay, PId) {
            const player = players.find(p => p.id === PId); 
            if (!player || !cardToPlay) return;
            
            // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ä»¥å¤–ã§ã‚«ãƒ¼ãƒ‰ã‚’ãƒ—ãƒ¬ã‚¤ã§ããªã„
            if (isMultiplayerMode && players[currentPlayerIndex].id !== "player1") {
                logMessage("ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ä¸­ã¯ã‚«ãƒ¼ãƒ‰ã‚’ãƒ—ãƒ¬ã‚¤ã§ãã¾ã›ã‚“", true);
                return;
            }
            
            const cardIndexInHand = player.hand.findIndex(c => c.uuid === cardToPlay.uuid);
            if (cardIndexInHand === -1) { 
                logMessage("ã‚¨ãƒ©ãƒ¼: å¬å–šã—ã‚ˆã†ã¨ã—ãŸã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"); 
                return; 
            }
            
            if (player.core < cardToPlay.cost) { 
                showMessage(`${player.name} ã®ã‚³ã‚¢ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚`); 
                return; 
            }
            
            if (cardToPlay.type === "unit") {
                if (player.fieldUnits.length >= MAX_UNITS_ON_FIELD) { 
                    showMessage(`${player.name} ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚¾ãƒ¼ãƒ³ã«ç©ºããŒã‚ã‚Šã¾ã›ã‚“ã€‚`); 
                    return; 
                }                player.core -= cardToPlay.cost;
                player.lastTurnCoreUsed = true; // ã‚³ã‚¢ã‚’ä½¿ç”¨ã—ãŸã®ã§ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                const playedCard = player.hand.splice(cardIndexInHand, 1)[0];
                playedCard.canAttack = !!playedCard.effects.some(e => e.type === "keyword" && e.name === "é€Ÿæ”»");
                playedCard.hasAttackedThisTurn = false; 
                player.fieldUnits.push(playedCard);
                logMessage(`${player.name} ã¯ ${playedCard.name} ã‚’å¬å–šï¼ (ã‚³ã‚¹ãƒˆ ${cardToPlay.cost})`, true);
                const onPlayEffect = playedCard.effects.find(e => e.type === "onPlay"); 
                if (onPlayEffect) handleOnPlayEffect(playedCard, onPlayEffect, player);
            } else if (cardToPlay.type === "trap") {
                if (player.fieldTrap) { 
                    showMessage(`${player.name} ã®ãƒˆãƒ©ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚`); 
                    return; 
                }                player.core -= cardToPlay.cost;
                player.lastTurnCoreUsed = true; // ã‚³ã‚¢ã‚’ä½¿ç”¨ã—ãŸã®ã§ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                const playedCard = player.hand.splice(cardIndexInHand, 1)[0];
                playedCard.isSet = true; 
                player.fieldTrap = playedCard; 
                logMessage(`${player.name} ã¯ãƒˆãƒ©ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã€Œ${playedCard.name}ã€ã‚’ã‚»ãƒƒãƒˆã—ãŸã€‚ (ã‚³ã‚¹ãƒˆ ${cardToPlay.cost})`, true);
            } else if (cardToPlay.type === "resource") {
                if (player.fieldResource) { 
                    showMessage(`${player.name} ã®ãƒªã‚½ãƒ¼ã‚¹ã‚¾ãƒ¼ãƒ³ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚`); 
                    return; 
                }                player.core -= cardToPlay.cost;
                player.lastTurnCoreUsed = true; // ã‚³ã‚¢ã‚’ä½¿ç”¨ã—ãŸã®ã§ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                const playedCard = player.hand.splice(cardIndexInHand, 1)[0];
                player.fieldResource = playedCard; 
                logMessage(`${player.name} ã¯ãƒªã‚½ãƒ¼ã‚¹ã‚«ãƒ¼ãƒ‰ã€Œ${playedCard.name}ã€ã‚’ãƒ—ãƒ¬ã‚¤ï¼ (ã‚³ã‚¹ãƒˆ ${cardToPlay.cost})`, true);
            }
            
            updateAllUI(); 
            checkWinCondition();
        }

        function displayAttackButton(unit) {
            attackActionAreaEl.innerHTML = ''; 
            const attackButton = document.createElement('button');
            attackButton.textContent = `${unit.name} ã§æ”»æ’ƒã™ã‚‹`;
            attackButton.classList.add('action-button', 'bg-orange-500', 'hover:bg-orange-700', 'text-white');
            attackButton.onclick = () => {
                attackActionPending = false; 
                attackTargetSelected = true; 
                logMessage(`${unit.name} ã®æ”»æ’ƒå¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`);
                attackActionAreaEl.innerHTML = ''; // æ”»æ’ƒãƒœã‚¿ãƒ³è‡ªèº«ã‚’æ¶ˆã™
                updateAllUI(); 
            };
            attackActionAreaEl.appendChild(attackButton);
            const cancelAttackButton = document.createElement('button');
            cancelAttackButton.textContent = 'æ”»æ’ƒã‚­ãƒ£ãƒ³ã‚»ãƒ«';
            cancelAttackButton.classList.add('action-button', 'bg-gray-400', 'hover:bg-gray-600', 'text-white');
            cancelAttackButton.onclick = () => {
                clearSelections();
                attackActionPending = false;
                attackTargetSelected = false;
                attackActionAreaEl.innerHTML = '';
                updateAllUI();
            };
            attackActionAreaEl.appendChild(cancelAttackButton);
        }


        function handleOnPlayEffect(playedCard, effect, effectOwnerPlayer) {
            logMessage(`${playedCard.name} ã®å ´ã«å‡ºãŸæ™‚åŠ¹æœç™ºå‹•: ${effect.action}`);
            if (effect.target === "opponentUnit" || effect.target === "playerUnit") {
                clearEffectSelection();
                effectTargetSelected = true;
                currentEffectAction = { sourceCardUUID: playedCard.uuid, effect: effect, sourcePlayer: effectOwnerPlayer, target: effect.target };
                logMessage(`åŠ¹æœå¯¾è±¡ã®${effect.target === "opponentUnit" ? "ç›¸æ‰‹" : "è‡ªåˆ†"}ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`);
                updateAllUI();
            } else {
                applyEffect(playedCard, effect, null, effectOwnerPlayer);
            }
        }
        function highlightTargets(attackerPlayer, defenderPlayer, attackingUnit) {
            clearHighlights();
            const tauntUnitsOnDefenderField = defenderPlayer.fieldUnits.filter(u => u.effects.some(e => e.type === "keyword" && e.name === "æŒ‘ç™º"));
            if (tauntUnitsOnDefenderField.length > 0) {
                tauntUnitsOnDefenderField.forEach(tauntUnit => {
                    const el = document.querySelector(`.card[data-uuid="${tauntUnit.uuid}"][data-owner="${defenderPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
            } else {
                defenderPlayer.fieldUnits.forEach(unit => {
                    const el = document.querySelector(`.card[data-uuid="${unit.uuid}"][data-owner="${defenderPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
                const opponentPlayerElement = defenderPlayer.playerElements.lpEl.parentElement;
                if (opponentPlayerElement) {
                     opponentPlayerElement.classList.add('targetable');
                     opponentPlayerElement.onclick = () => { 
                        if (attackTargetSelected && selectedPlayerCardUUID === attackingUnit.uuid) { 
                            performAttack(attackingUnit.uuid, attackerPlayer.id, defenderPlayer.id, null, "player");
                            attackActionPending = false; attackTargetSelected = false; attackActionAreaEl.innerHTML = ''; 
                            clearSelections(); // æ”»æ’ƒå¾Œã¯é¸æŠè§£é™¤
                            updateAllUI();
                        }
                     };
                }
            }
        }
        function highlightEffectTargets(effectOwnerPlayer, opponentPlayer, targetType) {
            clearHighlights();
            if (targetType === "opponentUnit") {
                opponentPlayer.fieldUnits.forEach(unit => {
                    const el = document.querySelector(`.card[data-uuid="${unit.uuid}"][data-owner="${opponentPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
            } else if (targetType === "playerUnit") {
                 effectOwnerPlayer.fieldUnits.forEach(unit => {
                    const el = document.querySelector(`.card[data-uuid="${unit.uuid}"][data-owner="${effectOwnerPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
            }
        }
        function clearHighlights() {
            document.querySelectorAll('.targetable').forEach(el => el.classList.remove('targetable'));
            players.forEach(p => {
                // playerElements ãŠã‚ˆã³ lpEl ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
                if (p && p.playerElements && p.playerElements.lpEl) {
                    const el = p.playerElements.lpEl.parentElement;
                    if (el) {
                        el.classList.remove('targetable');
                        el.onclick = null;
                    }
                }
            });
        }
        function clearSelections() {
            const previouslySelectedCardUUID = selectedPlayerCardUUID;
            const previouslySelectedOwnerId = selectedOwnerPlayerId;
            selectedPlayerCardUUID = null;
            selectedOwnerPlayerId = null; 
            // attackActionPending = false; // ã“ã“ã§ã¯ã‚¯ãƒªã‚¢ã›ãšã€æ”»æ’ƒãƒ•ãƒ­ãƒ¼ã®å®Œäº†æ™‚ã«è¡Œã†
            // attackTargetSelected = false; // åŒä¸Š
            if (previouslySelectedCardUUID && previouslySelectedOwnerId) {
                document.querySelectorAll(`.card[data-uuid="${previouslySelectedCardUUID}"][data-owner="${previouslySelectedOwnerId}"].selected-for-action`)
                    .forEach(el => el.classList.remove('selected-for-action'));
            }
            clearHighlights();
            // attackActionAreaEl.innerHTML = ''; // æ”»æ’ƒãƒœã‚¿ãƒ³ã‚‚ã‚¯ãƒªã‚¢ (çŠ¶æ³ã«ã‚ˆã‚‹)
        }
        function clearEffectSelection() {
            effectTargetSelected = false;
            currentEffectAction = null;
            clearHighlights();
        }        function promptBlockSelection(attackerUnit, attackedTarget, defenderPlayer) {
            logMessage(`${defenderPlayer.name} ã¯ãƒ–ãƒ­ãƒƒã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚ ${attackerUnit.name} ãŒ ${attackedTarget.name || attackedTarget.id} ã«æ”»æ’ƒã€‚`);
            blockInfoEl.innerHTML = `
                <p><b>${attackerUnit.name}</b> (æ”» ${attackerUnit.attack}) ãŒ <b>${attackedTarget.name || attackedTarget.id}</b> ã«æ”»æ’ƒã—ã¦ã„ã¾ã™ã€‚</p>
                <p>ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ</p>
            `;
            blockerSelectionAreaEl.innerHTML = '';
            selectedBlockerUUID = null; 

            const attackerIsFlying = attackerUnit.effects.some(e => e.type === "keyword" && e.name === "é£›è¡Œ");

            // ãƒ–ãƒ­ãƒƒã‚¯å¯èƒ½ãªãƒ¦ãƒ‹ãƒƒãƒˆã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
            const blockableUnits = defenderPlayer.fieldUnits.filter(unit => {
                let canBlock = true;
                // æ”»æ’ƒå¯¾è±¡ãŒé£›è¡Œãƒ¦ãƒ‹ãƒƒãƒˆã®å ´åˆã€é£›è¡ŒæŒã¡ãƒ¦ãƒ‹ãƒƒãƒˆã®ã¿ãŒãƒ–ãƒ­ãƒƒã‚¯å¯èƒ½
                if (attackedTarget.type === "unit" && attackedTarget.effects && 
                    attackedTarget.effects.some(e => e.type === "keyword" && e.name === "é£›è¡Œ")) {
                    if (!unit.effects.some(e => e.type === "keyword" && e.name === "é£›è¡Œ")) {
                        canBlock = false; 
                    }
                }
                // æ”»æ’ƒãƒ¦ãƒ‹ãƒƒãƒˆãŒé£›è¡Œã‚’æŒã¤å ´åˆã€é£›è¡ŒæŒã¡ãƒ¦ãƒ‹ãƒƒãƒˆã®ã¿ãŒãƒ–ãƒ­ãƒƒã‚¯å¯èƒ½
                if (attackerIsFlying && !unit.effects.some(e => e.type === "keyword" && e.name === "é£›è¡Œ")) {
                    canBlock = false;
                }
                // ç–²åŠ´çŠ¶æ…‹ã®ãƒ¦ãƒ‹ãƒƒãƒˆã¯ãƒ–ãƒ­ãƒƒã‚¯ã§ããªã„
                if (unit.isResting) {
                    canBlock = false;
                }
                return canBlock;
            });

            // ãƒ–ãƒ­ãƒƒã‚¯å¯èƒ½ãªãƒ¦ãƒ‹ãƒƒãƒˆã‚’è¡¨ç¤º
            if (blockableUnits.length === 0) {
                blockerSelectionAreaEl.innerHTML = '<p>ãƒ–ãƒ­ãƒƒã‚¯å¯èƒ½ãªãƒ¦ãƒ‹ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';
            } else {
                blockableUnits.forEach(unit => {
                    const cardEl = createCardElement(unit, defenderPlayer.id, "blockerCandidateDisplay"); 
                    cardEl.classList.add('blocker-candidate'); 
                    blockerSelectionAreaEl.appendChild(cardEl);
                });
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
            blockSelectModal.style.display = "flex";
        }        function handleBlockerUnitClick(blockerCard, ownerId) { 
            if (gamePhase !== "block_declare") return;
            const defenderPlayer = players.find(p => p.id === ownerId);
            if (!defenderPlayer || defenderPlayer.isTurnPlayer) return; 

            // é¸æŠçŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('#blockerSelectionArea .selected-for-action').forEach(el => el.classList.remove('selected-for-action'));
            defenderPlayer.playerElements.fieldUnitsEl.querySelectorAll('.selected-for-action').forEach(el => el.classList.remove('selected-for-action'));

            // åŒã˜ãƒ¦ãƒ‹ãƒƒãƒˆã‚’å†é¸æŠã—ãŸå ´åˆã¯é¸æŠè§£é™¤
            if (selectedBlockerUUID === blockerCard.uuid) { 
                selectedBlockerUUID = null;
                logMessage(`ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã®é¸æŠã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`, false);
            } else {
                // æ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã‚’é¸æŠ
                selectedBlockerUUID = blockerCard.uuid;
                const cardElInModal = document.querySelector(`#blockerSelectionArea .card[data-uuid="${blockerCard.uuid}"]`);
                if (cardElInModal) cardElInModal.classList.add('selected-for-action');
                
                const cardElOnField = defenderPlayer.playerElements.fieldUnitsEl.querySelector(`.card[data-uuid="${blockerCard.uuid}"]`);
                if (cardElOnField) cardElOnField.classList.add('selected-for-action');
                
                logMessage(`${blockerCard.name} ã‚’ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã¨ã—ã¦é¸æŠã—ã¾ã—ãŸã€‚`, false);
            }
        }

        function resolveCombat(attackerUnit, attackerPlayer, attackedTarget, defenderPlayer, blockerUnit) {
            attackerUnit.hasAttackedThisTurn = true;
            attackerUnit.isResting = true;

            if (blockerUnit) { 
                logMessage(`${attackerUnit.name} (æ”»${attackerUnit.attack}) vs ${blockerUnit.name} (æ”»${blockerUnit.attack}, ä½“${blockerUnit.currentHealth}) ã®æˆ¦é—˜ï¼`, true);
                let damageToBlocker = attackerUnit.attack; let damageToAttacker = blockerUnit.attack;
                const attackerHasPoison = attackerUnit.effects.some(e => e.type === "keyword" && e.name === "æ¯’");
                const blockerHasPoison = blockerUnit.effects.some(e => e.type === "keyword" && e.name === "æ¯’");
                blockerUnit.currentHealth -= damageToBlocker; logMessage(`${blockerUnit.name} ã¯ ${damageToBlocker} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚(æ®‹ä½“åŠ› ${blockerUnit.currentHealth})`, true);
                attackerUnit.currentHealth -= damageToAttacker; logMessage(`${attackerUnit.name} ã¯åæ’ƒã§ ${damageToAttacker} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚(æ®‹ä½“åŠ› ${attackerUnit.currentHealth})`, true);
                if (attackerHasPoison && damageToBlocker > 0 && blockerUnit.currentHealth > 0) { logMessage(`${attackerUnit.name} ã®æ¯’åŠ¹æœï¼ ${blockerUnit.name} ã¯ç ´å£Šã€‚`, true); blockerUnit.currentHealth = 0; }
                if (blockerHasPoison && damageToAttacker > 0 && attackerUnit.currentHealth > 0) { logMessage(`${blockerUnit.name} ã®æ¯’åŠ¹æœï¼ ${attackerUnit.name} ã¯ç ´å£Šã€‚`, true); attackerUnit.currentHealth = 0; }
                checkAndDestroyUnit(attackerUnit, attackerPlayer); checkAndDestroyUnit(blockerUnit, defenderPlayer);
            } else { 
                if (attackedTarget.type === "unit") { 
                    logMessage(`${attackerUnit.name} ãŒ ${attackedTarget.name} ã«ç›´æ¥æ”»æ’ƒï¼`, true);
                    let damageToTarget = attackerUnit.attack; const attackerHasPoison = attackerUnit.effects.some(e => e.type === "keyword" && e.name === "æ¯’");
                    attackedTarget.currentHealth -= damageToTarget; logMessage(`${attackedTarget.name} ã¯ ${damageToTarget} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚(æ®‹ä½“åŠ› ${attackedTarget.currentHealth})`, true);
                    if (attackerHasPoison && damageToTarget > 0 && attackedTarget.currentHealth > 0) { logMessage(`${attackerUnit.name} ã®æ¯’åŠ¹æœï¼ ${attackedTarget.name} ã¯ç ´å£Šã€‚`, true); attackedTarget.currentHealth = 0; }
                    checkAndDestroyUnit(attackedTarget, defenderPlayer); checkAndDestroyUnit(attackerUnit, attackerPlayer); 
                } else if (attackedTarget.type === "player" || attackedTarget.id === defenderPlayer.id) { 
                    logMessage(`${attackerUnit.name} ãŒ ${defenderPlayer.name} ã«ç›´æ¥æ”»æ’ƒï¼`, true);
                    defenderPlayer.lp -= attackerUnit.attack; logMessage(`${defenderPlayer.name} ã¯ ${attackerUnit.attack} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚(æ®‹LP ${defenderPlayer.lp})`, true);
                    checkAndDestroyUnit(attackerUnit, attackerPlayer); 
                }
            }
            updateAllUI(); checkWinCondition();
        }

        function performAttack(attackerUUID, attackerOwnerId, targetId, targetOwnerId, targetType) {
            const attackerPlayer = players.find(p => p.id === attackerOwnerId);
            const targetEntityOwner = targetType === "player" ? players.find(p => p.id === targetId) : players.find(p => p.id === targetOwnerId);
            if (!attackerPlayer || !targetEntityOwner) { logMessage("æ”»æ’ƒã‚¨ãƒ©ãƒ¼: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", true); clearSelections(); attackActionAreaEl.innerHTML = ''; updateAllUI(); return; }
            const attackerUnit = attackerPlayer.fieldUnits.find(u => u.uuid === attackerUUID);
            if (!attackerUnit || attackerUnit.hasAttackedThisTurn) { logMessage("æ”»æ’ƒã‚¨ãƒ©ãƒ¼: æ”»æ’ƒãƒ¦ãƒ‹ãƒƒãƒˆãŒç„¡åŠ¹ã‹ã€æ—¢ã«æ”»æ’ƒæ¸ˆã¿ã§ã™ã€‚", true); clearSelections(); attackActionAreaEl.innerHTML = ''; updateAllUI(); return; }
            let targetEntity;
            if (targetType === "unit") targetEntity = targetEntityOwner.fieldUnits.find(u => u.uuid === targetId);
            else targetEntity = targetEntityOwner; 
            if (!targetEntity) { logMessage("æ”»æ’ƒã‚¨ãƒ©ãƒ¼: æ”»æ’ƒå¯¾è±¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", true); clearSelections(); attackActionAreaEl.innerHTML = ''; updateAllUI(); return; }

            logMessage(`${attackerPlayer.name} ã® ${attackerUnit.name} ãŒ ${targetEntity.name || targetEntity.id} ã«æ”»æ’ƒå®£è¨€ï¼`, true);
            const trapHolder = players.find(p => p.id !== attackerPlayer.id); 
            if (trapHolder.fieldTrap && trapHolder.fieldTrap.isSet) {
                const trap = trapHolder.fieldTrap; const trapEffect = trap.effects.find(e => e.type === "onOpponentAttackDeclaration");
                if (trapEffect) {
                    logMessage(`${trapHolder.name} ã®ãƒˆãƒ©ãƒƒãƒ—ã€Œ${trap.name}ã€ãŒç™ºå‹•ï¼`, true);
                    const trapTarget = trapEffect.target === "attackingUnit" ? attackerUnit : null;
                    applyEffect(trap, trapEffect, trapTarget, trapHolder);
                    trapHolder.discardPile.push(trapHolder.fieldTrap); trapHolder.fieldTrap = null; updateAllUI();
                    if (!attackerPlayer.fieldUnits.some(u => u.uuid === attackerUUID) || (attackerUnit && attackerUnit.currentHealth <= 0)) {
                        logMessage(`${attackerUnit.name} ã¯ãƒˆãƒ©ãƒƒãƒ—ã«ã‚ˆã‚Šæˆ¦é—˜å‰ã«ç ´å£Šã•ã‚ŒãŸï¼`, true);
                        if(attackerUnit) attackerUnit.hasAttackedThisTurn = true; 
                        clearSelections(); attackActionAreaEl.innerHTML = ''; checkWinCondition(); changePhase("attack"); return; 
                    }
                }
            }
            currentAttackerInfo = { unit: attackerUnit, owner: attackerPlayer };
            currentAttackTargetInfo = { target: targetEntity, ownerId: targetEntityOwner.id, type: targetType };
            gamePhase = "block_declare"; subPhaseEl.textContent = "ãƒ–ãƒ­ãƒƒã‚¯å®£è¨€";
            attackActionAreaEl.innerHTML = ''; 
            updateAllUI();
            promptBlockSelection(attackerUnit, targetEntity, targetEntityOwner);
        }

        function checkAndDestroyUnit(unit, ownerPlayer) {
            if (unit.currentHealth <= 0) {
                logMessage(`${unit.name} ã¯ç ´å£Šã•ã‚ŒãŸã€‚`, true);
                ownerPlayer.fieldUnits = ownerPlayer.fieldUnits.filter(u => u.uuid !== unit.uuid);
                ownerPlayer.discardPile.push(unit);
                const onDestroyedEffect = unit.effects.find(e => e.type === "onDestroyed");
                if (onDestroyedEffect) applyEffect(unit, onDestroyedEffect, null, ownerPlayer);
            }
        }
        function applyEffect(sourceCard, effect, targetEntity, effectOwnerPlayer) {
            if (!sourceCard) {
                logMessage("ã‚¨ãƒ©ãƒ¼: åŠ¹æœã®ç™ºç”Ÿæºã‚«ãƒ¼ãƒ‰ (sourceCard) ãŒ null ã§ã™ã€‚", true);
                console.error("applyEffect was called with a null sourceCard.", { effect, targetEntity, effectOwnerPlayer });
                return;
            }
            const scName = sourceCard.name || "ä¸æ˜ãªã‚«ãƒ¼ãƒ‰";
            const efAction = effect ? effect.action : "ä¸æ˜ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³";
            const tgName = targetEntity ? (targetEntity.name || targetEntity.id) : 'ãªã—';
            const ownerName = effectOwnerPlayer ? effectOwnerPlayer.name : "ä¸æ˜ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼";

            logMessage(`åŠ¹æœç™ºå‹•: ${scName} ã® ${efAction} (å¯¾è±¡: ${tgName}, ç™ºå‹•è€…: ${ownerName})`, true);
            
            let actualTargetPlayer;
            switch (efAction) { // Use efAction which has a fallback
                case "draw": for (let i = 0; i < effect.value; i++) drawCard(effectOwnerPlayer); break;
                case "addCore": effectOwnerPlayer.core = Math.min(MAX_CORE, effectOwnerPlayer.core + effect.value); logMessage(`${ownerName} ã¯åŠ¹æœã§ ${effect.value} ã‚³ã‚¢ç²å¾—ã€‚`, true); break;
                case "damageUnit":
                    if (targetEntity && targetEntity.type === "unit") {
                        targetEntity.currentHealth -= effect.value; logMessage(`${tgName} ã¯åŠ¹æœã§ ${effect.value} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚æ®‹ã‚Šä½“åŠ› ${targetEntity.currentHealth}`, true);
                        const targetOwner = players.find(p => p.fieldUnits.some(u => u.uuid === targetEntity.uuid)); if (targetOwner) checkAndDestroyUnit(targetEntity, targetOwner);
                    } else logMessage(`åŠ¹æœå¯¾è±¡ã®ãƒ¦ãƒ‹ãƒƒãƒˆãŒã„ã¾ã›ã‚“ã€‚(${efAction})`, true);
                    break;
                case "damagePlayer":
                    actualTargetPlayer = (effect.target === "opponentPlayer") ? players.find(p => p.id !== effectOwnerPlayer.id) : effectOwnerPlayer;
                    if (actualTargetPlayer) { actualTargetPlayer.lp -= effect.value; logMessage(`${actualTargetPlayer.name} ã¯åŠ¹æœã§ ${effect.value} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚æ®‹ã‚ŠLP ${actualTargetPlayer.lp}`, true); }
                    break;
                case "healPlayer":
                    actualTargetPlayer = (effect.target === "self" || effect.target === "player") ? effectOwnerPlayer : players.find(p => p.id !== effectOwnerPlayer.id);
                    if (actualTargetPlayer) { actualTargetPlayer.lp += effect.value; logMessage(`${actualTargetPlayer.name} ã¯åŠ¹æœã§ ${effect.value} LPå›å¾©ã€‚æ®‹ã‚ŠLP ${actualTargetPlayer.lp}`, true); }
                    break;
                case "destroyUnit":
                     if (targetEntity && targetEntity.type === "unit") {
                        logMessage(`${tgName} ã¯åŠ¹æœã€Œ${scName}ã€ã§ç ´å£Šã•ã‚ŒãŸã€‚`, true); targetEntity.currentHealth = 0;
                        const targetOwner = players.find(p => p.fieldUnits.some(u => u.uuid === targetEntity.uuid)); if (targetOwner) checkAndDestroyUnit(targetEntity, targetOwner);
                    } else if (targetEntity && targetEntity.type === "trap" ) {
                        const trapOwner = players.find(p => p.fieldTrap && p.fieldTrap.uuid === targetEntity.uuid);
                        if (trapOwner) { trapOwner.discardPile.push(trapOwner.fieldTrap); trapOwner.fieldTrap = null; logMessage(`ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãŸ ${tgName} ã¯åŠ¹æœã€Œ${scName}ã€ã§ç ´å£Šã•ã‚ŒãŸã€‚`, true); }
                    } else logMessage(`åŠ¹æœå¯¾è±¡ã®ãƒ¦ãƒ‹ãƒƒãƒˆã¾ãŸã¯ãƒˆãƒ©ãƒƒãƒ—ãŒã„ã¾ã›ã‚“ã€‚(${efAction})`, true);
                    break;
            }
            updateAllUI(); checkWinCondition();
        }
        function findCardByUUID(uuid) {
            for (const player of players) {
                const cardInHand = player.hand.find(c => c.uuid === uuid); if (cardInHand) return cardInHand;
                const cardOnField = player.fieldUnits.find(c => c.uuid === uuid); if (cardOnField) return cardOnField;
                if (player.fieldTrap && player.fieldTrap.uuid === uuid) return player.fieldTrap;
                if (player.fieldResource && player.fieldResource.uuid === uuid) return player.fieldResource;
            }
            return null;
        }
        function checkWinCondition() {
            const player1 = players[0]; const player2 = players[1]; let winner = null;
            if (player1.lp <= 0 && player2.lp <= 0) { logMessage("å¼•ãåˆ†ã‘ï¼ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®LPãŒ0ä»¥ä¸‹ã«ãªã‚Šã¾ã—ãŸã€‚", true); winner = "draw"; }
            else if (player1.lp <= 0) { logMessage(`${player2.name} ã®å‹åˆ©ï¼ (${player1.name} ã®LPãŒ0)`, true); winner = player2; }
            else if (player2.lp <= 0) { logMessage(`${player1.name} ã®å‹åˆ©ï¼ (${player2.name} ã®LPãŒ0)`, true); winner = player1; }
            if (winner && gamePhase !== "gameOver") {
                gamePhase = "gameOver";
                if (winner === "draw") showMessage("å¼•ãåˆ†ã‘ï¼"); else showMessage(`${winner.name} ã®å‹åˆ©ï¼`);
                updateAllUI(); return true;
            }
            return false;
        }
        
        // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–¢é€£ã®å¤‰æ•°
        let ws = null;
        let clientId = null;
        let isMultiplayerMode = false;
        let isHost = false;
        let currentRoomId = null;
        
        // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ 
        const multiplayerButton = document.getElementById('multiplayerButton');
        const multiplayerModal = document.getElementById('multiplayerModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const serverUrlInput = document.getElementById('serverUrlInput');
        const connectionStatus = document.getElementById('connectionStatus');
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const roomNameInput = document.getElementById('roomNameInput');
        const createRoomButton = document.getElementById('createRoomButton');
        const refreshRoomsButton = document.getElementById('refreshRoomsButton');
        const roomsList = document.getElementById('roomsList');
        const closeMultiplayerModal = document.getElementById('closeMultiplayerModal');
        
        // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
        multiplayerButton.addEventListener('click', () => {
            multiplayerModal.style.display = 'flex';
        });
        
        // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«é–‰ã˜ã‚‹
        closeMultiplayerModal.addEventListener('click', () => {
            multiplayerModal.style.display = 'none';
        });
          // ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š
        connectButton.addEventListener('click', () => {
            const playerName = playerNameInput.value.trim() || `Player_${Math.floor(Math.random() * 1000)}`;
            let serverUrl = serverUrlInput.value.trim();
            
            if (!serverUrl) {
                alert('ã‚µãƒ¼ãƒãƒ¼URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            // URLã®å½¢å¼ã‚’ç¢ºèª
            if (!serverUrl.startsWith('ws://') && !serverUrl.startsWith('wss://')) {
                serverUrl = `ws://${serverUrl}`;
                serverUrlInput.value = serverUrl;
            }
            
            connectionStatus.textContent = 'æ¥ç¶šä¸­...';
            console.log(`WebSocketæ¥ç¶šä¸­: ${serverUrl}`);
            
            try {
                ws = new WebSocket(serverUrl);
                ws.onopen = () => {
                    connectionStatus.textContent = 'æ¥ç¶šã—ã¾ã—ãŸ';
                    connectButton.disabled = true;
                    disconnectButton.disabled = false;
                    createRoomButton.disabled = false;
                    refreshRoomsButton.disabled = false;
                    
                    // åå‰è¨­å®šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
                    ws.send(JSON.stringify({
                        type: 'setName',
                        name: playerName
                    }));
                    
                    // éƒ¨å±‹ä¸€è¦§å–å¾—
                    refreshRoomsList();
                };
                
                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    handleServerMessage(message);
                };
                  ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    connectionStatus.textContent = `ã‚¨ãƒ©ãƒ¼: æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ¼ãƒãƒ¼ãŒå®Ÿè¡Œä¸­ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
                    alert(`WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼: ã‚µãƒ¼ãƒãƒ¼(${serverUrl})ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
                };
                
                ws.onclose = () => {
                    connectionStatus.textContent = 'åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ';
                    connectButton.disabled = false;
                    disconnectButton.disabled = true;
                    createRoomButton.disabled = true;
                    refreshRoomsButton.disabled = true;
                    ws = null;
                };
                
            } catch (error) {
                console.error('Connection error:', error);
                connectionStatus.textContent = 'ã‚¨ãƒ©ãƒ¼: æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ';
            }
        });
        
        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­
        disconnectButton.addEventListener('click', () => {
            if (ws) {
                ws.close();
            }
        });
        
        // éƒ¨å±‹ä½œæˆ
        createRoomButton.addEventListener('click', () => {
            if (!ws) {
                alert('ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const roomName = roomNameInput.value.trim() || `Room_${Math.floor(Math.random() * 1000)}`;
            
            ws.send(JSON.stringify({
                type: 'createRoom',
                roomName: roomName
            }));
        });
        
        // éƒ¨å±‹ä¸€è¦§æ›´æ–°
        refreshRoomsButton.addEventListener('click', refreshRoomsList);        function refreshRoomsList() {
            if (!ws) return;
            
            // ã‚µãƒ¼ãƒãƒ¼URLã‹ã‚‰ãƒ›ã‚¹ãƒˆéƒ¨åˆ†ã‚’æŠ½å‡º
            const serverHost = serverUrlInput.value.replace('ws://', '');
            console.log(`éƒ¨å±‹ä¸€è¦§ã‚’å–å¾—: http://${serverHost}/api/rooms`);
            
            // APIã§éƒ¨å±‹ä¸€è¦§å–å¾—
            fetch(`http://${serverHost}/api/rooms`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(rooms => {
                    roomsList.innerHTML = '';
                    
                    if (rooms.length === 0) {
                        roomsList.innerHTML = '<div class="text-sm text-gray-500 italic">åˆ©ç”¨å¯èƒ½ãªéƒ¨å±‹ã¯ã‚ã‚Šã¾ã›ã‚“</div>';
                        return;
                    }
                    
                    rooms.forEach(room => {
                        const roomElement = document.createElement('div');
                        roomElement.className = 'p-2 border-b hover:bg-gray-100 cursor-pointer';
                        roomElement.innerHTML = `
                            <div class="font-medium">${room.name}</div>
                            <div class="text-sm text-gray-600">ãƒ›ã‚¹ãƒˆ: ${room.hostName}</div>
                        `;                        
                        roomElement.addEventListener('click', () => {
                            ws.send(JSON.stringify({
                                type: 'joinRoom',
                                roomId: room.id
                            }));
                            console.log(`éƒ¨å±‹ã«å‚åŠ ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡: ${room.name} (ID: ${room.id})`);
                            connectionStatus.textContent = `ã€Œ${room.name}ã€ã«å‚åŠ ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...`;
                        });
                        roomsList.appendChild(roomElement);
                    });
                })
                .catch(error => {
                    console.error('Error fetching rooms:', error);
                    roomsList.innerHTML = '<div class="text-sm text-red-500">éƒ¨å±‹ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸï¼š' + error.message + '</div>';
                });
        }
          // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
        function handleServerMessage(message) {
            console.log('Received message:', message);
            
            switch (message.type) {
                case 'connected':
                    clientId = message.clientId;
                    console.log(`ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¾ã—ãŸã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆID: ${clientId}`);
                    break;
                    
                case 'nameUpdated':
                    // åå‰ãŒæ›´æ–°ã•ã‚ŒãŸ
                    playerNameInput.value = message.name;
                    console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’è¨­å®š: ${message.name}`);
                    break;
                    
                case 'roomCreated':
                    // éƒ¨å±‹ãŒä½œæˆã•ã‚ŒãŸ
                    currentRoomId = message.roomId;
                    isHost = true;
                    connectionStatus.textContent = `éƒ¨å±‹ã€Œ${message.roomName}ã€ã‚’ä½œæˆã—ã¾ã—ãŸï¼ˆå‚åŠ è€…ã‚’å¾…ã£ã¦ã„ã¾ã™ï¼‰`;
                    console.log(`éƒ¨å±‹ã‚’ä½œæˆ: ${message.roomName} (ID: ${message.roomId})`);
                    break;
                    
                case 'joinedRoom':
                    // éƒ¨å±‹ã«å‚åŠ ã—ãŸ
                    currentRoomId = message.room.id;
                    isHost = false;
                    connectionStatus.textContent = `éƒ¨å±‹ã€Œ${message.room.name}ã€ã«å‚åŠ ã—ã¾ã—ãŸ`;
                    console.log(`éƒ¨å±‹ã«å‚åŠ : ${message.room.name} (ID: ${message.room.id})`);
                    break;
                    
                case 'playerJoined': // playerJoined ã¯ã‚²ã‚¹ãƒˆå‚åŠ æ™‚ã«ãƒ›ã‚¹ãƒˆã«é€šçŸ¥ã•ã‚Œã‚‹ã€‚ã‚²ãƒ¼ãƒ é–‹å§‹ã¯ gameStart ã§å‡¦ç†
                    console.log('Player joined the room:', message.player);
                    // UIæ›´æ–°ã‚„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãªã©ã€å¿…è¦ã«å¿œã˜ã¦
                    showMessage(`${message.player.name} ãŒå…¥å®¤ã—ã¾ã—ãŸã€‚`);
                    break;

                case 'gameStart': // ã‚²ãƒ¼ãƒ é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    multiplayerModal.style.display = 'none';
                    isMultiplayerMode = true;
                    console.log('Game starting with state:', message.gameState);
                    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã® gameState ã‚’ä½¿ã£ã¦ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
                    initializeGameFromState(message.gameState, message.hostPlayerId, message.guestPlayerId);
                    break;
                    
                case 'gameStateUpdate': // ã‚²ãƒ¼ãƒ çŠ¶æ…‹æ›´æ–°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    if (isMultiplayerMode) {
                        console.log('Received gameState update:', message.gameState);
                        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®æ–°ã—ã„ gameState ã§ãƒ­ãƒ¼ã‚«ãƒ«ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°
                        updateGameFromState(message.gameState);
                        // ãƒ­ã‚°ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œè€…ã¨å†…å®¹ã‚’è¨˜éŒ²ï¼ˆä»»æ„ï¼‰
                        const actionPlayer = message.gameState.players.find(p => p.id === message.actionOriginClientId);
                        if (actionPlayer) {
                            logMessage(`${actionPlayer.name} ãŒ ${message.originalAction} ã‚’å®Ÿè¡Œã—ã¾ã—ãŸã€‚`, true);
                        }
                    } else {
                        console.warn('Received gameStateUpdate but not in multiplayer mode.');
                    }
                    break;

                case 'opponentAction': // ã“ã‚Œã¯ gameStateUpdate ã«ç½®ãæ›ã‚ã‚‹æƒ³å®šã ãŒã€äº’æ›æ€§ã®ãŸã‚ã«æ®‹ã™ã‹æ¤œè¨
                    // ç›¸æ‰‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    if (isMultiplayerMode) {
                        console.log('ç›¸æ‰‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:', message.action, message.data);
                        handleOpponentAction(message.action, message.data);
                    } else {
                        console.warn('ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã§ãªã„ã®ã«ç›¸æ‰‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å—ä¿¡ã—ã¾ã—ãŸ');
                    }
                    break;
                    
                case 'error':
                    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    console.error('ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼:', message.message);
                    alert(`ã‚¨ãƒ©ãƒ¼: ${message.message}`);
                    break;
                      case 'roomClosed':
                    // éƒ¨å±‹ãŒé–‰ã˜ã‚‰ã‚ŒãŸ
                    console.log('éƒ¨å±‹ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ:', message.message);
                    alert('éƒ¨å±‹ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ: ' + message.message);
                    currentRoomId = null;
                    isHost = false;
                    isMultiplayerMode = false;
                    break;
                    
                case 'playerLeft':
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ãŸ
                    console.log('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡º:', message.message);
                    alert('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ã¾ã—ãŸ: ' + message.message);
                    break;
                    
                default:
                    // æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—
                    console.warn('æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—:', message);
                    break;
            }
        }
        
        // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚²ãƒ¼ãƒ é–‹å§‹ (ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®GameStateã§åˆæœŸåŒ–)
        function initializeGameFromState(serverGameState, hostId, guestId) {
            // è‡ªåˆ†ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆIDã¨ãƒ›ã‚¹ãƒˆID/ã‚²ã‚¹ãƒˆIDã‚’æ¯”è¼ƒã—ã¦ã€è‡ªåˆ†ãŒã©ã¡ã‚‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹åˆ¤æ–­
            const amIHost = clientId === hostId;
            const myPlayerServerState = amIHost ? serverGameState.players.find(p => p.id === hostId) : serverGameState.players.find(p => p.id === guestId);
            const opponentPlayerServerState = amIHost ? serverGameState.players.find(p => p.id === guestId) : serverGameState.players.find(p => p.id === hostId);

            if (!myPlayerServerState || !opponentPlayerServerState) {
                console.error("Could not determine player roles from server state.");
                showMessage("ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                return;
            }

            // players é…åˆ—ã‚’ã‚µãƒ¼ãƒãƒ¼ã®çŠ¶æ…‹ã«åˆã‚ã›ã¦è¨­å®š (è‡ªåˆ†ã‚’å¸¸ã« players[0] ã«ã™ã‚‹)
            players = [
                {
                    ...myPlayerServerState, // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®çŠ¶æ…‹ã‚’ã‚³ãƒ”ãƒ¼
                    id: "player1",          // UIä¸Šã®IDã¯å›ºå®š
                    isTurnPlayer: myPlayerServerState.isTurnPlayer, // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚¿ãƒ¼ãƒ³æƒ…å ±ã‚’æ¡ç”¨
                    // deck, discardPile ã¯ã‚µãƒ¼ãƒãƒ¼å´ã§æšæ•°ã®ã¿ç®¡ç†ã—ã¦ã„ã‚‹ãŸã‚ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§åˆ¥é€”åˆæœŸåŒ–ãŒå¿…è¦ãªå ´åˆãŒã‚ã‚‹
                    // ã“ã®ä¾‹ã§ã¯ã‚µãƒ¼ãƒãƒ¼ã® deckSize ã‚’ä½¿ã†
                    deck: Array(myPlayerServerState.deckSize).fill({}).map(() => createCardInstance(cardPool[Math.floor(Math.random() * cardPool.length)])), // ä»®ã®ãƒ‡ãƒƒã‚­ç”Ÿæˆ
                    discardPile: []
                },
                {
                    ...opponentPlayerServerState,
                    id: "player2",
                    isTurnPlayer: opponentPlayerServerState.isTurnPlayer,
                    deck: Array(opponentPlayerServerState.deckSize).fill({}).map(() => createCardInstance(cardPool[Math.floor(Math.random() * cardPool.length)])),
                    discardPile: []
                }
            ];

            // currentPlayerIndex ã‚’ã‚µãƒ¼ãƒãƒ¼ã®çŠ¶æ…‹ã«åŸºã¥ã„ã¦è¨­å®š
            currentPlayerIndex = players[0].isTurnPlayer ? 0 : 1;
            
            // ã‚²ãƒ¼ãƒ ãƒ•ã‚§ãƒ¼ã‚ºãªã©ã‚‚ã‚µãƒ¼ãƒãƒ¼ã®çŠ¶æ…‹ã‚’åæ˜ 
            gamePhase = serverGameState.gamePhase || "main"; // ã‚µãƒ¼ãƒãƒ¼ã«gamePhaseãŒãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            turnCount = serverGameState.gameLog ? serverGameState.gameLog.length : 1; // ç°¡æ˜“çš„ãªã‚¿ãƒ¼ãƒ³æ•°

            // AIãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹åŒ–
            isAIMode = false;
            isHost = amIHost; // isHost ãƒ•ãƒ©ã‚°ã‚‚è¨­å®š

            logMessage('ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰: ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™', true);
            logMessage(`${players[0].name} vs ${players[1].name}`, true);
            if (players[currentPlayerIndex]) {
                 logMessage(`${players[currentPlayerIndex].name} ã®ç•ªã§ã™`, true);
            } else {
                logMessage("ã‚¿ãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚", true);
            }
            
            updateAllUI();
            showMessage('å¯¾æˆ¦ç›¸æ‰‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼ã‚²ãƒ¼ãƒ é–‹å§‹ï¼');
        }

        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®GameStateã§æ—¢å­˜ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateGameFromState(serverGameState) {
            const amIHost = isHost; // initializeGameFromState ã§è¨­å®šã•ã‚ŒãŸ isHost ã‚’ä½¿ç”¨
            const myPlayerServerState = amIHost 
                ? serverGameState.players.find(p => p.id === clientId) 
                : serverGameState.players.find(p => p.id !== clientId && serverGameState.players.some(pl => pl.id === clientId)); // è‡ªåˆ†ãŒã‚²ã‚¹ãƒˆã®å ´åˆã€ç›¸æ‰‹ãŒãƒ›ã‚¹ãƒˆã®ã¯ãš
            
            const opponentPlayerServerState = amIHost 
                ? serverGameState.players.find(p => p.id !== clientId && serverGameState.players.some(pl => pl.id === clientId))
                : serverGameState.players.find(p => p.id === clientId);

            if (!myPlayerServerState || !opponentPlayerServerState) {
                console.error("Could not map server player state to local players.", serverGameState, clientId, isHost);
                // ã©ã¡ã‚‰ã‹ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€åŒæœŸãŒå–ã‚Œã¦ã„ãªã„å¯èƒ½æ€§
                // ã“ã“ã§ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚„å†åŒæœŸã®è©¦ã¿ãŒå¿…è¦ã«ãªã‚‹å ´åˆãŒã‚ã‚‹
                // ä»Šå›ã¯ã€è¦‹ã¤ã‹ã£ãŸæ–¹ã ã‘æ›´æ–°ã‚’è©¦ã¿ã‚‹
            }

            // players[0] (è‡ªåˆ†) ã®çŠ¶æ…‹ã‚’æ›´æ–°
            if (myPlayerServerState) {
                players[0] = {
                    ...players[0], // æ—¢å­˜ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´æƒ…å ±ã‚’ãƒ™ãƒ¼ã‚¹ã«
                    ...myPlayerServerState, // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®æƒ…å ±ã§ä¸Šæ›¸ã
                    id: "player1", // UIä¸Šã®IDã¯ä¸å¤‰
                    // deck, discardPile ã¯ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®æšæ•°æƒ…å ±ã«åŸºã¥ã„ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§èª¿æ•´ãŒå¿…è¦ãªå ´åˆãŒã‚ã‚‹
                    // ç°¡å˜ã®ãŸã‚ã€ã“ã“ã§ã¯ hand, fieldUnits, lp ãªã©ã‚’ç›´æ¥ä¸Šæ›¸ã
                };
            }

            // players[1] (ç›¸æ‰‹) ã®çŠ¶æ…‹ã‚’æ›´æ–°
            if (opponentPlayerServerState) {
                players[1] = {
                    ...players[1],
                    ...opponentPlayerServerState,
                    id: "player2",
                };
            }
            
            // currentPlayerIndex, gamePhase ãªã©ã‚’æ›´æ–°
            currentPlayerIndex = players[0].isTurnPlayer ? 0 : 1;
            gamePhase = serverGameState.gamePhase || gamePhase;
            // turnCount ãªã©ã‚‚å¿…è¦ã«å¿œã˜ã¦æ›´æ–°

            // ã‚²ãƒ¼ãƒ ãƒ­ã‚°ã‚’ã‚µãƒ¼ãƒãƒ¼ã®ã‚‚ã®ã«ç½®ãæ›ãˆã‚‹ã‹ã€è¿½è¨˜ã™ã‚‹ã‹ã¯è¨­è¨ˆã«ã‚ˆã‚‹
            // ã“ã®ä¾‹ã§ã¯ã€ã‚µãƒ¼ãƒãƒ¼ã®ãƒ­ã‚°ã§ä¸Šæ›¸ãï¼ˆãŸã ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§è¡¨ç¤ºç”¨ã«æ•´å½¢ãŒå¿…è¦ãªå ´åˆã‚‚ï¼‰
            if (serverGameState.gameLog) {
                gameLogEl.innerHTML = ''; // æ—¢å­˜ã®ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢
                serverGameState.gameLog.forEach(log => logMessage(log, false)); // ã‚µãƒ¼ãƒãƒ¼ã®ãƒ­ã‚°ã‚’è¡¨ç¤º
            }

            updateAllUI();
            // å¿…è¦ã«å¿œã˜ã¦ã€ç‰¹å®šã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãªã©
            // ä¾‹: if (message.originalAction === 'endTurn') showMessage(`${players[currentPlayerIndex].name} ã®ã‚¿ãƒ¼ãƒ³ã§ã™`);
        }

        // startMultiplayerGame ã¯ initializeGameFromState ã«ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ãŸã‚ã€
        // æ—¢å­˜ã® startMultiplayerGame ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ initializeGameFromState ã«çµ±åˆã•ã‚Œã‚‹ã‹ã€å‰Šé™¤/ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
        /*
        function startMultiplayerGame(gamePlayers) {
            // ... (ã“ã®é–¢æ•°ã¯ initializeGameFromState ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã—ãŸ) ...
        }
        */
        
        // ã‚µãƒ¼ãƒãƒ¼ã«ã‚²ãƒ¼ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡
        function sendGameAction(action, data) {
            if (!ws || !isMultiplayerMode) return;
            
            ws.send(JSON.stringify({
                type: 'gameAction',
                action: action,
                data: data
            }));
        }
          // ç›¸æ‰‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
        function handleOpponentAction(action, data) {
            console.log('Opponent action:', action, data);
            
            switch (action) {
                case 'endTurn':
                    // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³çµ‚äº†
                    logMessage("ç›¸æ‰‹ãŒã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ãŒå§‹ã¾ã‚Šã¾ã™ã€‚", true);
                    endTurn();
                    // è¡¨ç¤ºã‚’æ›´æ–°
                    updateAllUI();
                    break;
                    
                case 'playCard':
                    // ç›¸æ‰‹ãŒã‚«ãƒ¼ãƒ‰ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸ
                    logMessage(`ç›¸æ‰‹ãŒ ${data.cardName} ã‚’ãƒ—ãƒ¬ã‚¤ã—ã¾ã—ãŸ`, true);
                    // ã“ã“ã§ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹å‡¦ç†ã‚’è¿½åŠ 
                    break;
                    
                case 'attack':
                    // ç›¸æ‰‹ãŒæ”»æ’ƒ
                    logMessage(`ç›¸æ‰‹ãŒ ${data.attackerName} ã§æ”»æ’ƒã—ã¾ã—ãŸ`, true);
                    break;
                    
                default:
                    console.log(`æœªå®Ÿè£…ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ${action}`);
                    break;
            }
        }
          // ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«è¿½åŠ ã®å‡¦ç†ï¼ˆãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ï¼‰
        const originalEndTurn = endTurn;
        endTurn = function() {
            originalEndTurn();
            
            if (isMultiplayerMode) {
                console.log('ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰: ã‚¿ãƒ¼ãƒ³çµ‚äº†ã‚’é€šçŸ¥');
                // ç›¸æ‰‹ã«ã‚¿ãƒ¼ãƒ³çµ‚äº†ã‚’é€šçŸ¥
                sendGameAction('endTurn', {});
            }
        };
        
        document.addEventListener('DOMContentLoaded', () => {
            initGame();
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã®åˆæœŸå€¤ã‚’è¨­å®š
            playerNameInput.value = `Player_${Math.floor(Math.random() * 1000)}`;
        });
    </script>
</body>
</html>
