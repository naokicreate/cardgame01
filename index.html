<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç´„Éº„Éâ„Ç≤„Éº„É†„Éê„Éà„É´</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            overscroll-behavior: none;
        }
        .card {
            border: 1px solid #ccc; border-radius: 8px; padding: 4px; margin: 4px;
            width: 110px; height: 160px; display: flex; flex-direction: column;
            background-color: white; box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 0.7rem; position: relative;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 4px 4px 10px rgba(0,0,0,0.2); }
        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 2px; padding: 2px 4px;
        }
        .card-name { font-weight: bold; font-size: 0.75rem; flex-grow: 1; text-align: left; }
        .card-type { font-size: 0.6rem; color: #555; text-align: right; margin-left: 4px; }
        .card-cost {
            position: absolute; top: 2px; right: 2px; background-color: gold; color: black;
            border-radius: 50%; width: 22px; height: 22px; display: flex;
            align-items: center; justify-content: center; font-size: 0.7rem;
            font-weight: bold; border: 1px solid #b8860b; z-index: 10;
        }
        .card-image-placeholder {
            width: calc(100% - 8px); height: 70px; background-color: #e0e0e0;
            margin: 0 auto 4px auto; display: flex; align-items: center; justify-content: center;
            font-size: 0.65rem; color: #777; border-radius: 4px;
        }
        .card-image-placeholder img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .card-stats {
            display: flex; justify-content: space-around; font-size: 0.7rem;
            margin-top: 2px; padding: 0 4px; font-weight: bold;
        }
        .card-description {
            font-size: 0.6rem; margin-top: 2px; height: 38px; overflow-y: auto;
            border-top: 1px solid #eee; padding: 4px; line-height: 1.2;
        }
        .unit-card.can-attack { border: 2px solid limegreen; }
        .unit-card.has-attacked { border: 2px solid orange; }
        .unit-card.selected-card { outline: 3px solid dodgerblue !important; box-shadow: 0 0 10px dodgerblue; }
        .unit-card.blocker-candidate { outline: 3px solid cyan !important; }


        .field-zone {
            border: 2px dashed #aaa; min-height: 170px; display: flex; flex-wrap: wrap;
            align-items: flex-start; justify-content: center;
            padding: 20px 10px 10px 10px;
            margin-bottom:10px; background-color: rgba(0, 128, 0, 0.05);
            position: relative; border-radius: 8px;
        }
        .field-zone-label {
            position: absolute; top: 2px; right: 5px; font-size: 0.7rem; color: #666;
            background-color: rgba(255,255,255,0.7); padding: 1px 4px; border-radius: 3px;
        }
        .hand-zone {
            border: 2px dashed #66f; min-height: 170px; display: flex; flex-wrap: wrap;
            align-items: flex-start; justify-content: center; padding: 10px;
            background-color: rgba(100, 100, 255, 0.05); border-radius: 8px;
        }
        .player-area {
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px;
            border-radius: 8px; background-color: #f9f9f9;
        }
        .player-area.active-player { border-color: gold; box-shadow: 0 0 10px gold; }
        .player-area.blocking-player { border-color: cyan; box-shadow: 0 0 10px cyan; } /* Highlight for blocking player */
        .log-area {
            height: 150px; border: 1px solid #ccc; overflow-y: scroll;
            padding: 10px; margin-top: 20px; background-color: #f0f0f0;
            border-radius: 4px;
        }
        .action-button {
            padding: 8px 12px; margin: 5px; border-radius: 6px;
            cursor: pointer; font-weight: bold; transition: background-color 0.2s ease;
        }
        .targetable { outline: 3px solid red !important; cursor: crosshair; }
        .trap-card-set {
            background-color: purple; color: white; display: flex; align-items: center;
            justify-content: center; text-align: center;
        }
        .trap-card-set .card-header, .trap-card-set .card-image-placeholder,
        .trap-card-set .card-stats, .trap-card-set .card-description { display: none; }
        .trap-card-set::before { content: "SET TRAP"; color: white; font-weight: bold; font-size: 0.9rem; }
        .trap-card-set .card-cost { display: none; }

        /* Modal Base */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff; padding: 20px; border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); text-align: left;
            max-width: 90%; max-height: 90vh; overflow-y: auto;
        }
        
        #cardDetailModalContent {
            display: flex; width: 450px; max-width: 90%; padding: 15px;
        }
        .card-detail-image-column { flex: 0 0 150px; margin-right: 15px; display: flex; align-items: center; justify-content: center; }
        .card-detail-image-column img { max-width: 100%; max-height: 220px; border-radius: 8px; border: 1px solid #ccc; }
        .card-detail-info-column { flex: 1; display: flex; flex-direction: column; }
        .card-detail-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .card-detail-name { font-size: 1.2rem; font-weight: bold; margin-right: 10px; }
        .card-detail-type { font-size: 0.9rem; color: #555; }
        .card-detail-cost { font-size: 1rem; font-weight: bold; color: #8B4513; margin-bottom: 8px; }
        .card-detail-stats { font-size: 0.9rem; margin-bottom: 8px; }
        .card-detail-description {
            font-size: 0.85rem; line-height: 1.4; background-color: #f9f9f9; padding: 8px;
            border-radius: 4px; min-height: 60px; overflow-y: auto; flex-grow: 1;
        }
        #cardDetailModal .cancel-button { margin-top: 15px; float: right; }

        #summonConfirmModalContent { width: 300px; text-align: center; }
        #summonCardDisplay { margin-bottom: 15px; display: flex; justify-content: center;}
        .summon-button {
            background-color: #28a745; color: white; padding: 10px 15px;
            border: none; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .summon-button:disabled { background-color: #ccc; cursor: not-allowed; }
        .cancel-button {
            background-color: #6c757d; color: white; padding: 10px 15px;
            border: none; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .cancel-button:hover { background-color: #5a6268; }

        /* Block Selection Modal */
        #blockSelectModalContent { width: 500px; text-align: center; }
        #blockInfo { margin-bottom: 15px; }
        #blockerSelectionArea { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 15px; min-height: 100px;}
        .block-button {
            background-color: #007bff; color: white; padding: 10px 15px;
            border: none; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .block-button:hover { background-color: #0056b3; }


        #battleLogOverlay {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8); color: white;
            padding: 15px 25px; border-radius: 8px; z-index: 2000;
            font-size: 1.1rem; text-align: center;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        .core-display span { display: inline-block; margin-right: 2px; font-size: 1.2rem; }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto max-w-6xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-700">„Ç´„Éº„Éâ„Ç≤„Éº„É†„Éê„Éà„É´</h1>
        <div id="player2-area" class="player-area mb-4">
            <div class="flex justify-between items-center mb-2">
                <h2 id="player2-name" class="text-xl font-semibold text-gray-600">„Éó„É¨„Ç§„É§„Éº2</h2>
                <div>
                    <span class="mr-4">LP: <span id="player2-lp" class="font-bold">10000</span></span>
                    <span>„Ç≥„Ç¢: <span id="player2-core" class="font-bold core-display"></span></span>
                </div>
            </div>
            <div class="text-sm mb-2">ÊâãÊú≠: <span id="player2-hand-count">0</span>Êûö | „Éá„ÉÉ„Ç≠: <span id="player2-deck-count">20</span>Êûö | Êç®„Å¶Êú≠: <span id="player2-discard-count">0</span>Êûö</div>
            <div id="player2-hand" class="hand-zone bg-gray-200 p-2 rounded min-h-[170px] flex flex-wrap justify-center items-start"></div>
            <div class="grid grid-cols-1 md:grid-cols-7 gap-2 mt-2">
                <div id="player2-field-units" class="md:col-span-5 field-zone bg-green-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">„É¶„Éã„ÉÉ„Éà„Çæ„Éº„É≥</span></div>
                <div id="player2-field-trap" class="md:col-span-1 field-zone bg-purple-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">„Éà„É©„ÉÉ„Éó</span></div>
                <div id="player2-field-resource" class="md:col-span-1 field-zone bg-yellow-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">„É™„ÇΩ„Éº„Çπ</span></div>
            </div>
        </div>

        <div class="text-center my-4 p-3 bg-white shadow rounded">
            <p class="text-lg font-semibold">ÁèæÂú®„ÅÆ„Çø„Éº„É≥: <span id="current-turn-player" class="text-blue-600">„Éó„É¨„Ç§„É§„Éº1</span></p>
            <p class="text-lg">„Éï„Çß„Éº„Ç∫: <span id="current-phase" class="text-green-600">„Ç≤„Éº„É†Ê∫ñÂÇô‰∏≠</span> (<span id="sub-phase" class="text-orange-500"></span>)</p>
            <div id="action-buttons" class="mt-2"></div>
        </div>

        <div id="player1-area" class="player-area mt-4">
             <div class="flex justify-between items-center mb-2">
                <h2 id="player1-name" class="text-xl font-semibold text-gray-600">„Éó„É¨„Ç§„É§„Éº1</h2>
                <div>
                    <span class="mr-4">LP: <span id="player1-lp" class="font-bold">10000</span></span>
                    <span>„Ç≥„Ç¢: <span id="player1-core" class="font-bold core-display"></span></span>
                </div>
            </div>
            <div class="text-sm mb-2">ÊâãÊú≠: <span id="player1-hand-count">0</span>Êûö | „Éá„ÉÉ„Ç≠: <span id="player1-deck-count">20</span>Êûö | Êç®„Å¶Êú≠: <span id="player1-discard-count">0</span>Êûö</div>
            <div class="grid grid-cols-1 md:grid-cols-7 gap-2 mb-2">
                <div id="player1-field-units" class="md:col-span-5 field-zone bg-green-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">„É¶„Éã„ÉÉ„Éà„Çæ„Éº„É≥</span></div>
                <div id="player1-field-trap" class="md:col-span-1 field-zone bg-purple-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">„Éà„É©„ÉÉ„Éó</span></div>
                 <div id="player1-field-resource" class="md:col-span-1 field-zone bg-yellow-100 p-2 rounded min-h-[170px]"><span class="field-zone-label">„É™„ÇΩ„Éº„Çπ</span></div>
            </div>
            <div id="player1-hand" class="hand-zone bg-blue-100 p-2 rounded min-h-[170px] flex flex-wrap justify-center items-start"></div>
        </div>

        <div class="mt-6">
            <h3 class="text-lg font-semibold text-gray-700 mb-2">„Ç≤„Éº„É†„É≠„Ç∞</h3>
            <div id="game-log" class="log-area bg-white p-3 rounded shadow h-40 overflow-y-auto"><p>„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Åæ„Åô...</p></div>
        </div>
    </div>

    <div id="cardDetailModal" class="modal-overlay">
        <div id="cardDetailModalContent" class="modal-content"></div>
    </div>

    <div id="summonConfirmModal" class="modal-overlay">
        <div id="summonConfirmModalContent" class="modal-content">
            <p class="text-lg font-semibold mb-3">„Åì„ÅÆ„Ç´„Éº„Éâ„ÇíÂè¨Âñö„Åó„Åæ„Åô„ÅãÔºü</p>
            <div id="summonCardDisplay" class="flex justify-center"></div>
            <div id="summonActionButtons" class="mt-4">
                <button id="confirmSummonButton" class="summon-button">Âè¨Âñö„Åô„Çã</button>
                <button id="cancelSummonButton" class="cancel-button">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        </div>
    </div>

    <div id="blockSelectModal" class="modal-overlay">
        <div id="blockSelectModalContent" class="modal-content">
            <h3 class="text-xl font-semibold mb-3">„Éñ„É≠„ÉÉ„ÇØÈÅ∏Êäû</h3>
            <div id="blockInfo" class="mb-4"></div>
            <p class="mb-2">„Éñ„É≠„ÉÉ„ÇØ„Å´‰ΩøÁî®„Åô„ÇãËá™ÂàÜ„ÅÆ„É¶„Éã„ÉÉ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà‰ªªÊÑèÔºâÔºö</p>
            <div id="blockerSelectionArea" class="border p-2 rounded mb-4 min-h-[120px]">
                </div>
            <button id="confirmBlockButton" class="block-button">ÈÅ∏Êäû„Åó„Åü„É¶„Éã„ÉÉ„Éà„Åß„Éñ„É≠„ÉÉ„ÇØ</button>
            <button id="noBlockButton" class="cancel-button">„Éñ„É≠„ÉÉ„ÇØ„Åó„Å™„ÅÑ</button>
        </div>
    </div>
    
    <div id="battleLogOverlay"></div>
    <div id="messageModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <p id="modalMessageText"></p>
            <button id="modalCloseButton" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mt-3">OK</button>
        </div>
    </div>

    <script>
        // --- ÂÆöÊï∞, „Ç´„Éº„ÉâÂÆöÁæ©, „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ (Â§âÊõ¥ÁÇπ„ÅØ„Ç≥„É°„É≥„Éà„ÅßÁ§∫„Åô) ---
        const MAX_HAND_SIZE = 7; const INITIAL_LP = 10000; const INITIAL_CORE = 5; const MAX_CORE = 10;
        const CORE_PER_TURN = 3; const DECK_OUT_DAMAGE = 1000; const MAX_UNITS_ON_FIELD = 5;
        const CARD_PLACEHOLDER_IMAGE_URL = "https://placehold.co/130x180/e0e0e0/777?text=IMG";
        const GEM_EMOJI = 'üíé';

        // Removed the duplicate cardPool declaration here. The full one below is kept.

        const cardPool = [
            { id: "unit001", name: "„Ç¥„Éñ„É™„É≥", type: "unit", cost: 1, attack: 500, health: 600, effects: [], description: "„ÅãÂº±„ÅÑ„É¢„É≥„Çπ„Çø„Éº„ÄÇ„Å†„Åå„ÄÅ‰æÆ„Çã„Å®Áóõ„ÅÑÁõÆ„ÇíË¶ã„Çã„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„ÄÇÈõÜÂõ£„ÅßË•≤„ÅÑÊéõ„Åã„Çã„Åì„Å®„ÇíÂæóÊÑè„Å®„Åô„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/a9a9a9/ffffff?text=Goblin" },
            { id: "unit002", name: "„Ç™„Éº„ÇØ", type: "unit", cost: 3, attack: 800, health: 900, effects: [], description: "Â∞ë„Åó„Çø„Éï„Å™„É¢„É≥„Çπ„Çø„Éº„ÄÇÂäõËá™ÊÖ¢„Å†„Åå„ÄÅÈ†≠„ÅØ„ÅÇ„Åæ„ÇäËâØ„Åè„Å™„ÅÑ„Çà„ÅÜ„Å†„ÄÇ", illust_url: "https://placehold.co/100x70/8b4513/ffffff?text=Orc" },
            { id: "unit003", name: "„Éä„Ç§„Éà", type: "unit", cost: 4, attack: 700, health: 1200, effects: [{ type: "keyword", name: "ÊåëÁô∫" }], description: "„ÄêÊåëÁô∫„ÄëÂë≥Êñπ„ÇíÂÆà„ÇãÈ®éÂ£´„ÄÇ„Åù„ÅÆÂ†Ö„ÅÑÈéß„ÅØ‰ª≤Èñì„Åü„Å°„ÅÆÁõæ„Å®„Å™„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/c0c0c0/000000?text=Knight" },
            { id: "unit004", name: "„Ç∞„É™„Éï„Ç©„É≥", type: "unit", cost: 5, attack: 1000, health: 800, effects: [{ type: "keyword", name: "È£õË°å" }], description: "„ÄêÈ£õË°å„ÄëÁ©∫„ÇíËàû„ÅÜÁåõÁ¶Ω„ÄÇÂú∞‰∏ä„Åã„Çâ„ÅÆÊîªÊíÉ„ÇíÂèó„Åë‰ªò„Åë„Å™„ÅÑ„ÄÇ", illust_url: "https://placehold.co/100x70/ffd700/000000?text=Griffin" },
            { id: "unit005", name: "„Çπ„Éë„Ç§„ÉÄ„Éº", type: "unit", cost: 2, attack: 400, health: 400, effects: [{ type: "keyword", name: "ÊØí" }], description: "„ÄêÊØí„ÄëÂôõ„Åæ„Çå„Çã„Å®Âç±Èô∫„ÄÇ„Åù„ÅÆÁâô„Å´„ÅØÂº∑Âäõ„Å™ÊØí„Åå‰ªïËæº„Åæ„Çå„Å¶„ÅÑ„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/006400/ffffff?text=Spider" },
            { id: "unit006", name: "ÁñæÈ¢®„ÅÆÂÇ≠ÂÖµ", type: "unit", cost: 2, attack: 700, health: 500, effects: [{ type: "keyword", name: "ÈÄüÊîª" }], description: "„ÄêÈÄüÊîª„ÄëÁ¥†Êó©„ÅÑÊîªÊíÉ„ÄÇÊà¶Â†¥„Å´Âá∫„Çã„Å®ÂêåÊôÇ„Å´Ë•≤„ÅÑÊéõ„Åã„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/add8e6/000000?text=Mercenary" },
            { id: "unit007", name: "„Ç®„É´„Éï„ÅÆÂ∞ÑÊâã", type: "unit", cost: 3, attack: 600, health: 600, effects: [{ type: "onPlay", action: "damageUnit", value: 500, target: "opponentUnit" }], description: "„ÄêÂ†¥„Å´Âá∫„ÅüÊôÇ„ÄëÁõ∏Êâã„É¶„Éã„ÉÉ„Éà1‰Ωì„Å´500„ÉÄ„É°„Éº„Ç∏„ÄÇÊ£Æ„ÅÆÂ••Ê∑±„Åè„Åã„ÇâÊ≠£Á¢∫ÁÑ°ÊØî„Å™‰∏ÄÁü¢„ÇíÊîæ„Å§„ÄÇ", illust_url: "https://placehold.co/100x70/90ee90/000000?text=Archer" },
            { id: "unit008", name: "Ë≥¢ËÄÖ", type: "unit", cost: 4, attack: 300, health: 800, effects: [{ type: "onPlay", action: "draw", value: 1 }], description: "„ÄêÂ†¥„Å´Âá∫„ÅüÊôÇ„Äë„Ç´„Éº„Éâ„Çí1ÊûöÂºï„Åè„ÄÇÂè§„ÅÆÁü•Ë≠ò„ÅØÊñ∞„Åü„Å™Êà¶Áï•„ÇíÊéà„Åë„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/87ceeb/000000?text=Sage" },
            { id: "trap001", name: "ËêΩ„Å®„ÅóÁ©¥", type: "trap", cost: 2, effects: [{ type: "onOpponentAttackDeclaration", action: "destroyUnit", target: "attackingUnit" }], description: "Áõ∏Êâã„É¶„Éã„ÉÉ„Éà„ÅåÊîªÊíÉÂÆ£Ë®Ä„Åó„ÅüÊôÇ„ÄÅ„Åù„ÅÆÊîªÊíÉ„É¶„Éã„ÉÉ„Éà„ÇíÁ†¥Â£ä„Åô„Çã„ÄÇÂ∑ßÂ¶ô„Å´Èö†„Åï„Çå„ÅüÁΩ†„ÅåÊïµ„ÇíËë¨„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/800080/ffffff?text=Pitfall" },
            { id: "trap002", name: "È≠îÊ≥ïÂèçÂ∞Ñ", type: "trap", cost: 1, effects: [{ type: "onOpponentSpellPlay", action: "negateSpell" }], description: "Áõ∏Êâã„ÅåÂë™Êñá„Ç´„Éº„Éâ„Çí„Éó„É¨„Ç§„Åó„ÅüÊôÇ„ÄÅ„Åù„Çå„ÇíÁÑ°Âäπ„Å´„Åô„Çã„ÄÇ(Á∞°Áï•Âåñ) È≠îÂäõ„ÇíÂºæ„ÅèÁ•ûÁßò„ÅÆÈè°„ÄÇ", illust_url: "https://placehold.co/100x70/4b0082/ffffff?text=Reflect" },
            { id: "resource001", name: "Âäõ„ÅÆÊ∫ê", type: "resource", cost: 3, effects: [{ type: "continuous", phase: "start", action: "addCore", value: 1 }], description: "Ëá™ÂàÜ„ÅÆ„Çπ„Çø„Éº„Éà„Éï„Çß„Ç§„Ç∫ÈñãÂßãÊôÇ„ÄÅËøΩÂä†„Åß1„Ç≥„Ç¢„ÇíÂæó„Çã„ÄÇÂ∞Ω„Åç„Çã„Åì„Å®„ÅÆ„Å™„ÅÑÈ≠îÂäõ„ÅÆÊ≥â„ÄÇ", illust_url: "https://placehold.co/100x70/ffff00/000000?text=PowerSource" },
            { id: "resource002", name: "Áü•Ë≠ò„ÅÆÊ≥â", type: "resource", cost: 4, effects: [{ type: "continuous", phase: "draw", action: "draw", value: 1 }], description: "Ëá™ÂàÜ„ÅÆ„Éâ„É≠„Éº„Éï„Çß„Ç§„Ç∫ÊôÇ„ÄÅËøΩÂä†„Åß„Ç´„Éº„Éâ„Çí1ÊûöÂºï„Åè„ÄÇÂè°Êô∫„ÅØÂãùÂà©„Å∏„ÅÆÈçµ„Å®„Å™„Çã„ÄÇ", illust_url: "https://placehold.co/100x70/00ffff/000000?text=WisdomWell" },
        ];


        let players = [];
        let currentPlayerIndex = 0;
        let turnCount = 0;
        let gamePhase = "setup"; // setup, start, draw, main, attack, block_declare, end
        let subPhaseEl = document.getElementById('sub-phase'); // „Çµ„Éñ„Éï„Çß„Éº„Ç∫Ë°®Á§∫Áî®
        let selectedPlayerCardUUID = null;
        let selectedOwnerPlayerId = null;
        let attackTargetSelected = false;
        let effectTargetSelected = false;
        let currentEffectAction = null;
        let cardToSummon = null;
        let summonerPlayerId = null;
        // --- „Éñ„É≠„ÉÉ„ÇØÈÅ∏ÊäûÈñ¢ÈÄ£„ÅÆ„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ ---
        let currentAttackerInfo = null; // { unit: attackingUnit, owner: attackerPlayer }
        let currentAttackTargetInfo = null; // { target: targetEntity, ownerId: targetOwnerId, type: targetType }
        let selectedBlockerUUID = null;


        // --- DOMË¶ÅÁ¥† (Â§âÊõ¥ÁÇπ„ÅØ„Ç≥„É°„É≥„Éà„ÅßÁ§∫„Åô) ---
        const player1NameEl = document.getElementById('player1-name'); /* ... (‰ªñDOMË¶ÅÁ¥†„ÇÇÂêåÊßò) */
        const player1LpEl = document.getElementById('player1-lp');
        const player1CoreEl = document.getElementById('player1-core');
        const player1HandEl = document.getElementById('player1-hand');
        const player1HandCountEl = document.getElementById('player1-hand-count');
        const player1DeckCountEl = document.getElementById('player1-deck-count');
        const player1DiscardCountEl = document.getElementById('player1-discard-count');
        const player1FieldUnitsEl = document.getElementById('player1-field-units');
        const player1FieldTrapEl = document.getElementById('player1-field-trap');
        const player1FieldResourceEl = document.getElementById('player1-field-resource');
        const player2NameEl = document.getElementById('player2-name');
        const player2LpEl = document.getElementById('player2-lp');
        const player2CoreEl = document.getElementById('player2-core');
        const player2HandEl = document.getElementById('player2-hand');
        const player2HandCountEl = document.getElementById('player2-hand-count');
        const player2DeckCountEl = document.getElementById('player2-deck-count');
        const player2DiscardCountEl = document.getElementById('player2-discard-count');
        const player2FieldUnitsEl = document.getElementById('player2-field-units');
        const player2FieldTrapEl = document.getElementById('player2-field-trap');
        const player2FieldResourceEl = document.getElementById('player2-field-resource');
        const currentTurnPlayerEl = document.getElementById('current-turn-player');
        const currentPhaseEl = document.getElementById('current-phase');
        const actionButtonsEl = document.getElementById('action-buttons');
        const gameLogEl = document.getElementById('game-log');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const cardDetailModalEl = document.getElementById('cardDetailModal');
        const cardDetailModalContentEl = document.getElementById('cardDetailModalContent');
        const summonConfirmModal = document.getElementById('summonConfirmModal');
        const summonCardDisplay = document.getElementById('summonCardDisplay');
        const confirmSummonButton = document.getElementById('confirmSummonButton');
        const cancelSummonButton = document.getElementById('cancelSummonButton');
        const battleLogOverlay = document.getElementById('battleLogOverlay');
        // --- „Éñ„É≠„ÉÉ„ÇØÈÅ∏Êäû„É¢„Éº„ÉÄ„É´„ÅÆDOMË¶ÅÁ¥† ---
        const blockSelectModal = document.getElementById('blockSelectModal');
        const blockInfoEl = document.getElementById('blockInfo');
        const blockerSelectionAreaEl = document.getElementById('blockerSelectionArea');
        const confirmBlockButton = document.getElementById('confirmBlockButton');
        const noBlockButton = document.getElementById('noBlockButton');


        // --- Event Listeners for Modals („Éñ„É≠„ÉÉ„ÇØÈÅ∏Êäû„É¢„Éº„ÉÄ„É´Èñ¢ÈÄ£„ÇíËøΩÂä†) ---
        modalCloseButton.onclick = () => { messageModal.style.display = "none"; };
        cancelSummonButton.onclick = () => { summonConfirmModal.style.display = "none"; cardToSummon = null; summonerPlayerId = null; };
        confirmSummonButton.onclick = () => {
            if (cardToSummon && summonerPlayerId) actuallyPlayCard(cardToSummon, summonerPlayerId);
            summonConfirmModal.style.display = "none"; cardToSummon = null; summonerPlayerId = null;
        };
        [messageModal, cardDetailModalEl, summonConfirmModal, blockSelectModal].forEach(modal => {
            modal.onclick = (event) => {
                if (event.target === modal) {
                    modal.style.display = "none";
                    if (modal === summonConfirmModal) { cardToSummon = null; summonerPlayerId = null; }
                    if (modal === blockSelectModal) { /* resetBlockSelectionState(); */ } // ÂøÖË¶Å„Å™„Çâ„É™„Çª„ÉÉ„ÉàÂá¶ÁêÜ
                }
            };
        });
        confirmBlockButton.onclick = () => {
            if (currentAttackerInfo && currentAttackTargetInfo && selectedBlockerUUID) {
                const defenderPlayer = players.find(p => p.id === currentAttackTargetInfo.ownerId || (currentAttackTargetInfo.type === 'player' && p.id === currentAttackTargetInfo.target.id)); // Èò≤Âæ°ÂÅ¥„Éó„É¨„Ç§„É§„Éº
                const blockerUnit = defenderPlayer.fieldUnits.find(u => u.uuid === selectedBlockerUUID);
                if (blockerUnit) {
                    logMessage(`${defenderPlayer.name} „ÅÆ ${blockerUnit.name} „Åå„Éñ„É≠„ÉÉ„ÇØÔºÅ`, true);
                    resolveCombat(currentAttackerInfo.unit, currentAttackerInfo.owner, currentAttackTargetInfo.target, defenderPlayer, blockerUnit);
                }
            }
            blockSelectModal.style.display = "none";
            resetBlockSelectionState();
            changePhase("attack"); // ÊîªÊíÉ„Éï„Çß„Ç§„Ç∫„ÅÆÊ¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å∏ („Åæ„Åü„ÅØ„É°„Ç§„É≥„Éï„Çß„Ç§„Ç∫„Å´Êàª„Çã)
        };
        noBlockButton.onclick = () => {
            logMessage("„Éñ„É≠„ÉÉ„ÇØ„Åó„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ", true);
            if (currentAttackerInfo && currentAttackTargetInfo) {
                resolveCombat(currentAttackerInfo.unit, currentAttackerInfo.owner, currentAttackTargetInfo.target, players.find(p=>p.id === currentAttackTargetInfo.ownerId || (currentAttackTargetInfo.type === 'player' && p.id === currentAttackTargetInfo.target.id) ), null); // „Éñ„É≠„ÉÉ„Ç´„Éº„Å™„Åó
            }
            blockSelectModal.style.display = "none";
            resetBlockSelectionState();
            changePhase("attack");
        };


        // --- Helper Functions (showCardDetail, logMessage, showBattleLogOverlay„Å™„Å©ÂâçÂõû„Å®Âêå„Åò„ÇÇ„ÅÆ„ÅØÁúÅÁï•) ---
        function showMessage(message) { /* ... */ }
        function logMessage(message, isBattleLog = false) { /* ... */ }
        function generateUUID() { /* ... */ }
        function createCardInstance(cardData) { /* ... */ }
        function showBattleLogOverlay(message) { /* ... */ }
        function showCardDetail(cardData, ownerId) { /* ... */ }
        // (showMessage, logMessage, generateUUID, createCardInstance, showBattleLogOverlay, showCardDetail „ÅØÂâçÂõû„Å®Âêå„Åò)
        function showMessage(message) {
            modalMessageText.textContent = message;
            messageModal.style.display = "flex";
        }
        function logMessage(message, isBattleLog = false) {
            const p = document.createElement('p');
            p.textContent = message;
            gameLogEl.appendChild(p);
            gameLogEl.scrollTop = gameLogEl.scrollHeight;
            if (isBattleLog) {
                showBattleLogOverlay(message);
            }
        }
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        function createCardInstance(cardData) {
            const instance = JSON.parse(JSON.stringify(cardData));
            instance.uuid = generateUUID();
            if (instance.type === "unit") {
                instance.currentHealth = instance.health;
                instance.canAttack = false;
                instance.hasAttackedThisTurn = false;
                instance.isResting = false;
            }
            instance.isSet = false;
            return instance;
        }
        function showBattleLogOverlay(message) {
            battleLogOverlay.textContent = message;
            battleLogOverlay.style.display = "block";
            setTimeout(() => {
                battleLogOverlay.style.display = "none";
            }, 1500);
        }
        function showCardDetail(cardData, ownerId) {
            cardDetailModalContentEl.innerHTML = '';
            const imgCol = document.createElement('div');
            imgCol.classList.add('card-detail-image-column');
            const img = document.createElement('img');
            img.src = cardData.illust_url || CARD_PLACEHOLDER_IMAGE_URL;
            img.alt = cardData.name;
            imgCol.appendChild(img);
            cardDetailModalContentEl.appendChild(imgCol);

            const infoCol = document.createElement('div');
            infoCol.classList.add('card-detail-info-column');
            const header = document.createElement('div');
            header.classList.add('card-detail-header');
            const nameEl = document.createElement('div');
            nameEl.classList.add('card-detail-name');
            nameEl.textContent = cardData.name;
            header.appendChild(nameEl);
            const typeEl = document.createElement('div');
            typeEl.classList.add('card-detail-type');
            typeEl.textContent = cardData.type.toUpperCase();
            header.appendChild(typeEl);
            infoCol.appendChild(header);
            const costEl = document.createElement('div');
            costEl.classList.add('card-detail-cost');
            costEl.innerHTML = `„Ç≥„Çπ„Éà: <span style="color: gold;">${GEM_EMOJI.repeat(cardData.cost)}</span> (${cardData.cost})`;
            infoCol.appendChild(costEl);
            if (cardData.type === "unit") {
                const statsEl = document.createElement('div');
                statsEl.classList.add('card-detail-stats');
                statsEl.textContent = `ÊîªÊíÉÂäõ: ${cardData.attack} / ‰ΩìÂäõ: ${cardData.currentHealth || cardData.health}`;
                infoCol.appendChild(statsEl);
            }
            const descEl = document.createElement('div');
            descEl.classList.add('card-detail-description');
            descEl.textContent = cardData.description;
            infoCol.appendChild(descEl);
            const closeButton = document.createElement('button');
            closeButton.classList.add('cancel-button');
            closeButton.textContent = 'Èñâ„Åò„Çã';
            closeButton.style.marginTop = 'auto';
            closeButton.style.alignSelf = 'flex-end';
            closeButton.onclick = () => { cardDetailModalEl.style.display = "none"; };
            infoCol.appendChild(closeButton);
            cardDetailModalContentEl.appendChild(infoCol);
            cardDetailModalEl.style.display = "flex";
        }

        function resetBlockSelectionState() {
            currentAttackerInfo = null;
            currentAttackTargetInfo = null;
            selectedBlockerUUID = null;
            document.querySelectorAll('.blocker-candidate').forEach(el => el.classList.remove('blocker-candidate'));
            players.forEach(p => p.playerElements.areaEl.classList.remove('blocking-player'));
            subPhaseEl.textContent = "";
        }
        
        function initGame() { /* ... (ÂâçÂõû„Å®Âêå„Åò) ... */ }
        function updateAllUI() { /* ... („Ç≥„Ç¢Ë°®Á§∫‰ª•Â§ñ„ÅØÂâçÂõû„Å®Âêå„Åò) ... */ }
        function getPhaseNameJP(phase) { /* ... */ }
        function createCardElement(card, ownerPlayerId, location = "hand") { /* ... (blocker-candidate„ÇØ„É©„Çπ„ÅÆÂá¶ÁêÜËøΩÂä†) ... */ }
        function renderHand(player) { /* ... */ }
        function renderFieldUnits(player) { /* ... */ }
        function renderFieldTrap(player) { /* ... */ }
        function renderFieldResource(player) { /* ... */ }
        function changePhase(newPhase) { /* ... (block_declare„Éï„Çß„Éº„Ç∫ËøΩÂä†) ... */ }
        function handleStartPhase() { /* ... */ }
        function handleDrawPhase() { /* ... */ }
        function drawCard(player, log = true) { /* ... */ }
        function handleMainPhase() { /* ... */ }
        function handleAttackPhaseEntry() { /* ... */ }
        // (initGame, updateAllUI, getPhaseNameJP, createCardElement, renderHand, renderFieldUnits, renderFieldTrap, renderFieldResource, changePhase, handleStartPhase, handleDrawPhase, drawCard, handleMainPhase, handleAttackPhaseEntry, handleEndPhase, updateActionButtons, handleCardClick, actuallyPlayCard, handleFieldUnitClick, handleOnPlayEffect, highlightTargets, highlightEffectTargets, clearHighlights, clearSelections, clearEffectSelection, checkAndDestroyUnit, applyEffect, findCardByUUID, checkWinCondition „ÅØÂâçÂõû„Å®Âêå„Åò„ÅãÂæÆ‰øÆÊ≠£)
        function initGame() {
            logMessage("„Ç≤„Éº„É†„ÇíÂàùÊúüÂåñ„Åó„Å¶„ÅÑ„Åæ„Åô...");
            players = [
                {
                    id: "player1", name: "„Éó„É¨„Ç§„É§„Éº1", lp: INITIAL_LP, core: INITIAL_CORE, deck: [], hand: [],
                    fieldUnits: [], fieldTrap: null, fieldResource: null, discardPile: [], isTurnPlayer: true,
                    playerElements: {
                        nameEl: player1NameEl, lpEl: player1LpEl, coreEl: player1CoreEl,
                        handEl: player1HandEl, handCountEl: player1HandCountEl,
                        deckCountEl: player1DeckCountEl, discardCountEl: player1DiscardCountEl,
                        fieldUnitsEl: player1FieldUnitsEl, fieldTrapEl: player1FieldTrapEl,
                        fieldResourceEl: player1FieldResourceEl, areaEl: document.getElementById('player1-area')
                    }
                },
                {
                    id: "player2", name: "„Éó„É¨„Ç§„É§„Éº2", lp: INITIAL_LP, core: INITIAL_CORE, deck: [], hand: [],
                    fieldUnits: [], fieldTrap: null, fieldResource: null, discardPile: [], isTurnPlayer: false,
                    playerElements: {
                        nameEl: player2NameEl, lpEl: player2LpEl, coreEl: player2CoreEl,
                        handEl: player2HandEl, handCountEl: player2HandCountEl,
                        deckCountEl: player2DeckCountEl, discardCountEl: player2DiscardCountEl,
                        fieldUnitsEl: player2FieldUnitsEl, fieldTrapEl: player2FieldTrapEl,
                        fieldResourceEl: player2FieldResourceEl, areaEl: document.getElementById('player2-area')
                    }
                }
            ];

            function buildPlayerDeck() {
                let deck = [];
                const unitCards = cardPool.filter(c => c.type === 'unit');
                const trapCards = cardPool.filter(c => c.type === 'trap');
                const resourceCards = cardPool.filter(c => c.type === 'resource');
                for(let i=0; i<14; i++) deck.push(createCardInstance(unitCards[i % unitCards.length]));
                for(let i=0; i<3; i++) deck.push(createCardInstance(trapCards[i % trapCards.length]));
                for(let i=0; i<3; i++) deck.push(createCardInstance(resourceCards[i % resourceCards.length]));
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }

            players.forEach(player => {
                player.deck = buildPlayerDeck();
                for (let i = 0; i < 3; i++) {
                    drawCard(player, false);
                }
            });

            currentPlayerIndex = 0;
            players[0].isTurnPlayer = true;
            players[1].isTurnPlayer = false;
            turnCount = 1;
            
            resetBlockSelectionState(); // ÂàùÊúüÂåñÊôÇ„Å´„ÇÇÂëº„Å∂
            clearSelections();
            clearEffectSelection();
            updateAllUI();
            logMessage(`${players[currentPlayerIndex].name} „ÅÆ„Çø„Éº„É≥„Åß„Ç≤„Éº„É†ÈñãÂßãÔºÅ`);
            changePhase("start");
        }

        function updateAllUI() {
            players.forEach(player => {
                player.playerElements.nameEl.textContent = player.name;
                player.playerElements.lpEl.textContent = player.lp;
                player.playerElements.coreEl.innerHTML = '';
                for (let i = 0; i < player.core; i++) {
                    const gemSpan = document.createElement('span');
                    gemSpan.textContent = GEM_EMOJI;
                    player.playerElements.coreEl.appendChild(gemSpan);
                }
                if (player.core === 0) {
                     player.playerElements.coreEl.textContent = '0';
                }
                player.playerElements.handCountEl.textContent = player.hand.length;
                player.playerElements.deckCountEl.textContent = player.deck.length;
                player.playerElements.discardCountEl.textContent = player.discardPile.length;
                renderHand(player);
                renderFieldUnits(player);
                renderFieldTrap(player);
                renderFieldResource(player);

                player.playerElements.areaEl.classList.remove('blocking-player'); // Reset blocking highlight
                if (gamePhase === "block_declare" && player.id === (players[(currentPlayerIndex + 1) % players.length]).id) {
                     player.playerElements.areaEl.classList.add('blocking-player');
                } else if (player.isTurnPlayer) {
                    player.playerElements.areaEl.classList.add('active-player');
                } else {
                    player.playerElements.areaEl.classList.remove('active-player');
                }
            });

            currentTurnPlayerEl.textContent = players[currentPlayerIndex].name;
            currentPhaseEl.textContent = getPhaseNameJP(gamePhase);
            subPhaseEl.textContent = gamePhase === "block_declare" ? "„Éñ„É≠„ÉÉ„ÇØÂÆ£Ë®Ä" : "";
            updateActionButtons();

            if (attackTargetSelected && selectedPlayerCardUUID) {
                const player = players.find(p => p.id === selectedOwnerPlayerId);
                if (player) {
                    const opponent = players.find(p => p.id !== player.id);
                    const attackerUnit = player.fieldUnits.find(u => u.uuid === selectedPlayerCardUUID);
                    if (attackerUnit && opponent) {
                        highlightTargets(player, opponent, attackerUnit);
                    }
                }
            } else if (effectTargetSelected && currentEffectAction) {
                const player = currentEffectAction.sourcePlayer;
                const opponent = players.find(p => p.id !== player.id);
                if (player && opponent) {
                    highlightEffectTargets(player, opponent, currentEffectAction.target);
                }
            }
        }

        function getPhaseNameJP(phase) {
            switch(phase) {
                case "setup": return "„Ç≤„Éº„É†Ê∫ñÂÇô‰∏≠";
                case "start": return "„Çπ„Çø„Éº„Éà„Éï„Çß„Ç§„Ç∫";
                case "draw": return "„Éâ„É≠„Éº„Éï„Çß„Ç§„Ç∫";
                case "main": return "„É°„Ç§„É≥„Éï„Çß„Ç§„Ç∫";
                case "attack": return "ÊîªÊíÉ„Éï„Çß„Ç§„Ç∫";
                case "block_declare": return "ÊîªÊíÉ„Éï„Çß„Ç§„Ç∫"; // „É°„Ç§„É≥„Éï„Çß„Éº„Ç∫„ÅØÊîªÊíÉ„ÅÆ„Åæ„Åæ
                case "end": return "„Ç®„É≥„Éâ„Éï„Çß„Ç§„Ç∫";
                case "gameOver": return "„Ç≤„Éº„É†ÁµÇ‰∫Ü";
                default: return phase;
            }
        }

        function createCardElement(card, ownerPlayerId, location = "hand") {
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card', `${card.type}-card`);
            cardDiv.dataset.uuid = card.uuid;
            cardDiv.dataset.owner = ownerPlayerId;

            if (card.uuid === selectedPlayerCardUUID && ownerPlayerId === selectedOwnerPlayerId) {
                cardDiv.classList.add('selected-card');
            }
            if (location === "blockerCandidateDisplay" && card.uuid === selectedBlockerUUID) { // Changed from "blockerCandidate"
                cardDiv.classList.add('selected-card'); 
            }


            const costEl = document.createElement('div');
            costEl.classList.add('card-cost');
            costEl.textContent = card.cost;
            cardDiv.appendChild(costEl);
            const headerEl = document.createElement('div');
            headerEl.classList.add('card-header');
            const nameEl = document.createElement('div');
            nameEl.classList.add('card-name');
            nameEl.textContent = card.name;
            headerEl.appendChild(nameEl);
            const typeEl = document.createElement('div');
            typeEl.classList.add('card-type');
            typeEl.textContent = card.type.toUpperCase();
            headerEl.appendChild(typeEl);
            cardDiv.appendChild(headerEl);
            const imgPlaceholderEl = document.createElement('div');
            imgPlaceholderEl.classList.add('card-image-placeholder');
            const imgContent = document.createElement('img');
            imgContent.src = card.illust_url;
            imgContent.alt = card.name;
            imgContent.onerror = () => { imgContent.src = "https://placehold.co/100x70/e0e0e0/777?text=Error"; };
            imgPlaceholderEl.appendChild(imgContent);
            cardDiv.appendChild(imgPlaceholderEl);

            if (card.type === "unit") {
                const statsEl = document.createElement('div');
                statsEl.classList.add('card-stats');
                statsEl.innerHTML = `<span>Êîª:${card.attack}</span><span>‰Ωì:${card.currentHealth || card.health}</span>`;
                cardDiv.appendChild(statsEl);
                if (card.canAttack && !card.hasAttackedThisTurn) cardDiv.classList.add('can-attack');
                if (card.hasAttackedThisTurn) cardDiv.classList.add('has-attacked');
            }
            
            const descriptionEl = document.createElement('div');
            descriptionEl.classList.add('card-description');
            descriptionEl.textContent = card.description;
            cardDiv.appendChild(descriptionEl);

            if (card.type === "trap" && card.isSet) {
                cardDiv.classList.add('trap-card-set');
            }

            if (location !== "detail" && location !== "summon" && location !== "blockerCandidateDisplay") {
                cardDiv.onclick = (e) => {
                    e.stopPropagation();
                    if (gamePhase === "block_declare" && location === "fieldUnit" && ownerPlayerId !== players[currentPlayerIndex].id) {
                        // „Éñ„É≠„ÉÉ„ÇØÂÆ£Ë®Ä„Éï„Çß„Ç§„Ç∫‰∏≠„ÄÅÈò≤Âæ°ÂÅ¥„Éó„É¨„Ç§„É§„Éº„ÅÆ„Éï„Ç£„Éº„É´„Éâ„É¶„Éã„ÉÉ„Éà„ÇØ„É™„ÉÉ„ÇØ
                        handleBlockerUnitClick(card, ownerPlayerId);
                    } else {
                        handleCardClick(card, ownerPlayerId, location);
                    }
                };
            } else if (location === "blockerCandidateDisplay") { // „Éñ„É≠„ÉÉ„ÇØÈÅ∏Êäû„É¢„Éº„ÉÄ„É´ÂÜÖ„ÅÆ„Ç´„Éº„Éâ
                 cardDiv.onclick = (e) => {
                    e.stopPropagation();
                    handleBlockerUnitClick(card, ownerPlayerId); // „Åì„Çå„ÇÇ„Éñ„É≠„ÉÉ„Ç´„ÉºÈÅ∏ÊäûÁî®
                };
            }
            return cardDiv;
        }
        
        function renderHand(player) {
            player.playerElements.handEl.innerHTML = '';
            if (player.hand.length === 0 && player.id === "player1") {
                 player.playerElements.handEl.textContent = "ÊâãÊú≠„Å™„Åó";
            } else if (player.hand.length === 0 && player.id === "player2") {
                 player.playerElements.handEl.innerHTML = `<div class="text-gray-500 p-4">Áõ∏Êâã„ÅÆÊâãÊú≠„Å™„Åó</div>`;
            }
            else {
                player.hand.forEach(card => {
                    player.playerElements.handEl.appendChild(createCardElement(card, player.id, "hand"));
                });
            }
        }
        function renderFieldUnits(player) {
            const label = player.playerElements.fieldUnitsEl.querySelector('.field-zone-label');
            player.playerElements.fieldUnitsEl.innerHTML = '';
            if (label) player.playerElements.fieldUnitsEl.appendChild(label);
            player.fieldUnits.forEach(unit => {
                const cardEl = createCardElement(unit, player.id, "fieldUnit");
                if (gamePhase === "block_declare" && player.id !== players[currentPlayerIndex].id && unit.uuid === selectedBlockerUUID) {
                    cardEl.classList.add('selected-card'); // ÈÅ∏Êäû„Åï„Çå„Åü„Éñ„É≠„ÉÉ„Ç´„Éº„Çí„Éè„Ç§„É©„Ç§„Éà
                }
                player.playerElements.fieldUnitsEl.appendChild(cardEl);
            });
        }
        function renderFieldTrap(player) {
            const label = player.playerElements.fieldTrapEl.querySelector('.field-zone-label');
            player.playerElements.fieldTrapEl.innerHTML = '';
            if (label) player.playerElements.fieldTrapEl.appendChild(label);
            if (player.fieldTrap) {
                player.playerElements.fieldTrapEl.appendChild(createCardElement(player.fieldTrap, player.id, "fieldTrap"));
            }
        }
        function renderFieldResource(player) {
            const label = player.playerElements.fieldResourceEl.querySelector('.field-zone-label');
            player.playerElements.fieldResourceEl.innerHTML = '';
            if (label) player.playerElements.fieldResourceEl.appendChild(label);
            if (player.fieldResource) {
                player.playerElements.fieldResourceEl.appendChild(createCardElement(player.fieldResource, player.id, "fieldResource"));
            }
        }
        function changePhase(newPhase) {
            if (checkWinCondition()) return;
            const oldPhase = gamePhase;
            gamePhase = newPhase;
            if (oldPhase === "block_declare" && newPhase === "attack") {
                subPhaseEl.textContent = "";
            } else {
                 logMessage(`${players[currentPlayerIndex].name} - ${getPhaseNameJP(newPhase)}ÈñãÂßã`);
            }
            clearSelections();
            if (newPhase !== "block_declare") { 
                 clearEffectSelection();
            }
            updateAllUI();
            switch (newPhase) {
                case "start": handleStartPhase(); break;
                case "draw": handleDrawPhase(); break;
                case "main": handleMainPhase(); break;
                case "attack": handleAttackPhaseEntry(); break;
                case "end": handleEndPhase(); break;
            }
        }
        function handleStartPhase() {
            const player = players[currentPlayerIndex];
            if (player.fieldResource) {
                const resourceEffect = player.fieldResource.effects.find(e => e.type === "continuous" && e.phase === "start");
                if (resourceEffect) applyEffect(player.fieldResource, resourceEffect, player, null);
            }
            player.core = Math.min(MAX_CORE, player.core + CORE_PER_TURN);
            logMessage(`${player.name} „ÅØ ${CORE_PER_TURN} „Ç≥„Ç¢Áç≤Âæó„ÄÇ`);
            player.fieldUnits.forEach(unit => { unit.canAttack = true; unit.hasAttackedThisTurn = false; unit.isResting = false; });
            updateAllUI();
        }
        function handleDrawPhase() {
            const player = players[currentPlayerIndex];
            drawCard(player);
            if (player.fieldResource) {
                const resourceEffect = player.fieldResource.effects.find(e => e.type === "continuous" && e.phase === "draw");
                if (resourceEffect) applyEffect(player.fieldResource, resourceEffect, player, null);
            }
            updateAllUI();
        }
        function drawCard(player, log = true) {
            if (player.deck.length > 0) {
                if (player.hand.length < MAX_HAND_SIZE) {
                    const card = player.deck.pop(); player.hand.push(card);
                    if(log) logMessage(`${player.name} „ÅØ„Ç´„Éº„Éâ„Äå${card.name}„Äç„ÇíÂºï„ÅÑ„Åü„ÄÇ`);
                } else {
                    const card = player.deck.pop(); player.discardPile.push(card);
                    if(log) logMessage(`${player.name} „ÅØ„Ç´„Éº„Éâ„Äå${card.name}„Äç„ÇíÂºï„ÅÑ„Åü„ÅåÊâãÊú≠‰∏äÈôê„ÅÆ„Åü„ÇÅÊç®„Å¶Êú≠„Å∏„ÄÇ`);
                }
            } else {
                if(log) logMessage(`${player.name} „ÅÆ„Éá„ÉÉ„Ç≠„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅ ${DECK_OUT_DAMAGE} „ÉÄ„É°„Éº„Ç∏„ÄÇ`, true);
                player.lp -= DECK_OUT_DAMAGE;
                if (checkWinCondition()) return;
            }
        }
        function handleMainPhase() {
            logMessage(`${players[currentPlayerIndex].name} „ÅÆ„É°„Ç§„É≥„Éï„Çß„Ç§„Ç∫„ÄÇ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`);
        }
        function handleAttackPhaseEntry() {
            const player = players[currentPlayerIndex];
            const attackableUnits = player.fieldUnits.filter(u => u.canAttack && !u.hasAttackedThisTurn);
            if (attackableUnits.length === 0 && gamePhase === "attack") { 
                logMessage("ÊîªÊíÉÂèØËÉΩ„Å™„É¶„Éã„ÉÉ„Éà„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ");
            }
        }
        function handleEndPhase() {
            const player = players[currentPlayerIndex];
            if (player.hand.length > MAX_HAND_SIZE) {
                const excessCount = player.hand.length - MAX_HAND_SIZE;
                for (let i = 0; i < excessCount; i++) {
                    const discardedCard = player.hand.shift(); player.discardPile.push(discardedCard);
                    logMessage(`${player.name} „ÅØÊâãÊú≠‰∏äÈôê„ÇíË∂Ö„Åà„Åü„Åü„ÇÅ ${discardedCard.name} „ÇíÊç®„Å¶„Åü„ÄÇ`);
                }
            }
            player.isTurnPlayer = false;
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            players[currentPlayerIndex].isTurnPlayer = true;
            turnCount++;
            logMessage(`„Çø„Éº„É≥ÁµÇ‰∫Ü„ÄÇÊ¨°„ÅØ ${players[currentPlayerIndex].name} „ÅÆ„Çø„Éº„É≥„Åß„Åô„ÄÇ`);
            changePhase("start");
        }
        function updateActionButtons() {
            actionButtonsEl.innerHTML = '';
            if (gamePhase === "gameOver") {
                const restartButton = document.createElement('button');
                restartButton.textContent = "„Ç≤„Éº„É†„ÇíÂÜçÈñã„Åô„Çã";
                restartButton.classList.add('action-button', 'bg-blue-500', 'hover:bg-blue-700', 'text-white');
                restartButton.onclick = () => { gameLogEl.innerHTML = ''; initGame(); };
                actionButtonsEl.appendChild(restartButton);
                return;
            }
            if (gamePhase === "block_declare") { 
                actionButtonsEl.innerHTML = `<p class="text-cyan-600 font-semibold">${players[(currentPlayerIndex + 1) % players.length].name} „Åå„Éñ„É≠„ÉÉ„ÇØ„ÇíÈÅ∏Êäû‰∏≠„Åß„Åô...</p>`;
                return;
            }

            switch (gamePhase) {
                case "start":
                    const toDrawButton = document.createElement('button');
                    toDrawButton.textContent = "„Éâ„É≠„Éº„Éï„Çß„Ç§„Ç∫„Å∏";
                    toDrawButton.classList.add('action-button', 'bg-green-500', 'hover:bg-green-700', 'text-white');
                    toDrawButton.onclick = () => changePhase("draw");
                    actionButtonsEl.appendChild(toDrawButton);
                    break;
                case "draw":
                    const toMainButtonFromDraw = document.createElement('button');
                    toMainButtonFromDraw.textContent = "„É°„Ç§„É≥„Éï„Çß„Ç§„Ç∫„Å∏";
                    toMainButtonFromDraw.classList.add('action-button', 'bg-green-500', 'hover:bg-green-700', 'text-white');
                    toMainButtonFromDraw.onclick = () => changePhase("main");
                    actionButtonsEl.appendChild(toMainButtonFromDraw);
                    break;
                case "main":
                    const toAttackButton = document.createElement('button');
                    toAttackButton.textContent = "ÊîªÊíÉ„Éï„Çß„Ç§„Ç∫„Å∏";
                    toAttackButton.classList.add('action-button', 'bg-red-500', 'hover:bg-red-700', 'text-white');
                    toAttackButton.onclick = () => changePhase("attack");
                    actionButtonsEl.appendChild(toAttackButton);
                    const toEndButtonFromMain = document.createElement('button');
                    toEndButtonFromMain.textContent = "„Çø„Éº„É≥ÁµÇ‰∫Ü";
                    toEndButtonFromMain.classList.add('action-button', 'bg-gray-500', 'hover:bg-gray-700', 'text-white');
                    toEndButtonFromMain.onclick = () => changePhase("end");
                    actionButtonsEl.appendChild(toEndButtonFromMain);
                    break;
                case "attack":
                    const toEndButtonFromAttack = document.createElement('button');
                    toEndButtonFromAttack.textContent = "ÊîªÊíÉÁµÇ‰∫Ü („É°„Ç§„É≥„Å∏)";
                    toEndButtonFromAttack.classList.add('action-button', 'bg-blue-500', 'hover:bg-blue-700', 'text-white');
                    toEndButtonFromAttack.onclick = () => { logMessage("ÊîªÊíÉ„Éï„Çß„Ç§„Ç∫„ÇíÁµÇ‰∫Ü„Åó„ÄÅ„É°„Ç§„É≥„Éï„Çß„Ç§„Ç∫„Å´Êàª„Çä„Åæ„Åô„ÄÇ"); changePhase("main"); };
                    actionButtonsEl.appendChild(toEndButtonFromAttack);
                    const directToEndButton = document.createElement('button');
                    directToEndButton.textContent = "„Çø„Éº„É≥ÁµÇ‰∫Ü";
                    directToEndButton.classList.add('action-button', 'bg-gray-500', 'hover:bg-gray-700', 'text-white');
                    directToEndButton.onclick = () => changePhase("end");
                    actionButtonsEl.appendChild(directToEndButton);
                    break;
            }
        }
        function handleCardClick(card, ownerPlayerId, location) {
            showCardDetail(card, ownerPlayerId);
            const player = players.find(p => p.id === ownerPlayerId);
            if (!player) return;
            if (location === "hand" && gamePhase === "main" && player.isTurnPlayer) {
                cardToSummon = card;
                summonerPlayerId = ownerPlayerId;
                summonCardDisplay.innerHTML = '';
                const cardElementForSummon = createCardElement(card, ownerPlayerId, "summon");
                cardElementForSummon.style.cursor = "default";
                summonCardDisplay.appendChild(cardElementForSummon);
                confirmSummonButton.disabled = player.core < card.cost;
                summonConfirmModal.style.display = "flex";
            } else if (location === "fieldUnit" && player.isTurnPlayer && gamePhase === "attack") {
                 handleFieldUnitClick(card.uuid, ownerPlayerId);
            } else if (location === "fieldUnit" && player.isTurnPlayer && gamePhase === "main") {
                handleFieldUnitClick(card.uuid, ownerPlayerId);
            }
        }
        function actuallyPlayCard(cardToPlay, PId) {
            const player = players.find(p => p.id === PId);
            if (!player || !cardToPlay) return;
            const cardIndexInHand = player.hand.findIndex(c => c.uuid === cardToPlay.uuid);
            if (cardIndexInHand === -1) { logMessage("„Ç®„É©„Éº: Âè¨Âñö„Åó„Çà„ÅÜ„Å®„Åó„Åü„Ç´„Éº„Éâ„ÅåÊâãÊú≠„Å´Ë¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ"); return; }
            if (player.core < cardToPlay.cost) { showMessage(`${player.name} „ÅÆ„Ç≥„Ç¢„ÅåË∂≥„Çä„Åæ„Åõ„Çì„ÄÇ`); return; }

            if (cardToPlay.type === "unit") {
                if (player.fieldUnits.length >= MAX_UNITS_ON_FIELD) { showMessage(`${player.name} „ÅÆ„É¶„Éã„ÉÉ„Éà„Çæ„Éº„É≥„Å´Á©∫„Åç„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ`); return; }
                player.core -= cardToPlay.cost;
                const playedCard = player.hand.splice(cardIndexInHand, 1)[0];
                playedCard.canAttack = !!playedCard.effects.some(e => e.type === "keyword" && e.name === "ÈÄüÊîª");
                playedCard.hasAttackedThisTurn = false;
                player.fieldUnits.push(playedCard);
                logMessage(`${player.name} „ÅØ ${playedCard.name} „ÇíÂè¨ÂñöÔºÅ („Ç≥„Çπ„Éà ${cardToPlay.cost})`, true);
                const onPlayEffect = playedCard.effects.find(e => e.type === "onPlay");
                if (onPlayEffect) { handleOnPlayEffect(playedCard, onPlayEffect, player); }
            } else if (cardToPlay.type === "trap") {
                if (player.fieldTrap) { showMessage(`${player.name} „ÅÆ„Éà„É©„ÉÉ„Éó„Çæ„Éº„É≥„ÅØÊó¢„Å´‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`); return; }
                player.core -= cardToPlay.cost;
                const playedCard = player.hand.splice(cardIndexInHand, 1)[0];
                playedCard.isSet = true; player.fieldTrap = playedCard;
                logMessage(`${player.name} „ÅØ„Éà„É©„ÉÉ„Éó„Ç´„Éº„Éâ„Äå${playedCard.name}„Äç„Çí„Çª„ÉÉ„Éà„Åó„Åü„ÄÇ („Ç≥„Çπ„Éà ${cardToPlay.cost})`, true);
            } else if (cardToPlay.type === "resource") {
                 if (player.fieldResource) { showMessage(`${player.name} „ÅÆ„É™„ÇΩ„Éº„Çπ„Çæ„Éº„É≥„ÅØÊó¢„Å´‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`); return; }
                player.core -= cardToPlay.cost;
                const playedCard = player.hand.splice(cardIndexInHand, 1)[0];
                player.fieldResource = playedCard;
                logMessage(`${player.name} „ÅØ„É™„ÇΩ„Éº„Çπ„Ç´„Éº„Éâ„Äå${playedCard.name}„Äç„Çí„Éó„É¨„Ç§ÔºÅ („Ç≥„Çπ„Éà ${cardToPlay.cost})`, true);
            }
            updateAllUI(); checkWinCondition();
        }
        function handleFieldUnitClick(unitUUID, ownerPlayerId) {
            const unitOwner = players.find(p => p.id === ownerPlayerId);
            if (!unitOwner) return;
            const unit = unitOwner.fieldUnits.find(u => u.uuid === unitUUID);
            if (!unit) return;

            if (attackTargetSelected) { 
                const attackerOwner = players.find(p => p.id === selectedOwnerPlayerId);
                if (!attackerOwner) { clearSelections(); updateAllUI(); return; }
                const attackerUnit = attackerOwner.fieldUnits.find(u => u.uuid === selectedPlayerCardUUID);
                if (attackerUnit && unitOwner.id !== attackerOwner.id) { 
                    const tauntUnits = unitOwner.fieldUnits.filter(u => u.effects.some(e => e.type === "keyword" && e.name === "ÊåëÁô∫"));
                    if (tauntUnits.length > 0 && !tauntUnits.some(tu => tu.uuid === unit.uuid)) {
                        showMessage("ÊåëÁô∫„É¶„Éã„ÉÉ„Éà„Åå„ÅÑ„Åæ„Åô„ÄÇ„Åù„Å°„Çâ„ÇíÂÖà„Å´ÊîªÊíÉ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"); return;
                    }
                    currentAttackerInfo = { unit: attackerUnit, owner: attackerOwner };
                    currentAttackTargetInfo = { target: unit, ownerId: unitOwner.id, type: "unit" };
                    gamePhase = "block_declare"; 
                    subPhaseEl.textContent = "„Éñ„É≠„ÉÉ„ÇØÂÆ£Ë®Ä";
                    updateAllUI(); 
                    promptBlockSelection(attackerUnit, unit, unitOwner);
                }
                clearSelections(); 
                return;
            }
            if (effectTargetSelected && currentEffectAction) {
                const sourceCard = findCardByUUID(currentEffectAction.sourceCardUUID);
                const effectSourcePlayer = currentEffectAction.sourcePlayer;
                if (currentEffectAction.target === "opponentUnit" && unitOwner.id !== effectSourcePlayer.id) {
                    applyEffect(sourceCard, currentEffectAction.effect, unit, effectSourcePlayer);
                    clearEffectSelection(); updateAllUI();
                } else if (currentEffectAction.target === "playerUnit" && unitOwner.id === effectSourcePlayer.id) {
                    applyEffect(sourceCard, currentEffectAction.effect, unit, effectSourcePlayer);
                    clearEffectSelection(); updateAllUI();
                }
                return;
            }
            if (gamePhase === "attack" && unitOwner.isTurnPlayer) {
                if (!unit.canAttack) { showMessage(`${unit.name} „ÅØË°åÂãï„Åß„Åç„Åæ„Åõ„Çì„ÄÇ`); return; }
                if (unit.hasAttackedThisTurn) { showMessage(`${unit.name} „ÅØÊó¢„Å´ÊîªÊíÉÊ∏à„Åø„Åß„Åô„ÄÇ`); return; }
                clearSelections();
                selectedPlayerCardUUID = unit.uuid;
                selectedOwnerPlayerId = unitOwner.id;
                attackTargetSelected = true;
                logMessage(`${unitOwner.name} „ÅÆ ${unit.name} „ÅßÊîªÊíÉ„Åó„Åæ„Åô„ÄÇÊîªÊíÉÂØæË±°„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`);
                updateAllUI();
            } else if (gamePhase === "main" && unitOwner.isTurnPlayer) {
                 logMessage(`${unitOwner.name} „ÅÆ ${unit.name} „ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü„ÄÇ(„É°„Ç§„É≥„Éï„Çß„Ç§„Ç∫)`);
                clearSelections();
                selectedPlayerCardUUID = unit.uuid;
                selectedOwnerPlayerId = unitOwner.id;
                updateAllUI();
            }
        }
        function handleOnPlayEffect(playedCard, effect, effectOwnerPlayer) {
            logMessage(`${playedCard.name} „ÅÆÂ†¥„Å´Âá∫„ÅüÊôÇÂäπÊûúÁô∫Âãï: ${effect.action}`);
            if (effect.target === "opponentUnit" || effect.target === "playerUnit") {
                clearEffectSelection();
                effectTargetSelected = true;
                currentEffectAction = { sourceCardUUID: playedCard.uuid, effect: effect, sourcePlayer: effectOwnerPlayer, target: effect.target };
                logMessage(`ÂäπÊûúÂØæË±°„ÅÆ${effect.target === "opponentUnit" ? "Áõ∏Êâã" : "Ëá™ÂàÜ"}„É¶„Éã„ÉÉ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`);
                updateAllUI();
            } else {
                applyEffect(playedCard, effect, null, effectOwnerPlayer);
            }
        }
        function highlightTargets(attackerPlayer, defenderPlayer, attackingUnit) {
            clearHighlights();
            const tauntUnitsOnDefenderField = defenderPlayer.fieldUnits.filter(u => u.effects.some(e => e.type === "keyword" && e.name === "ÊåëÁô∫"));
            if (tauntUnitsOnDefenderField.length > 0) {
                tauntUnitsOnDefenderField.forEach(tauntUnit => {
                    const el = document.querySelector(`.card[data-uuid="${tauntUnit.uuid}"][data-owner="${defenderPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
            } else {
                defenderPlayer.fieldUnits.forEach(unit => {
                    const el = document.querySelector(`.card[data-uuid="${unit.uuid}"][data-owner="${defenderPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
                const opponentPlayerElement = defenderPlayer.playerElements.lpEl.parentElement;
                if (opponentPlayerElement) {
                     opponentPlayerElement.classList.add('targetable');
                     opponentPlayerElement.onclick = () => { 
                        if (attackTargetSelected && selectedPlayerCardUUID === attackingUnit.uuid) {
                            currentAttackerInfo = { unit: attackingUnit, owner: attackerPlayer };
                            currentAttackTargetInfo = { target: defenderPlayer, ownerId: defenderPlayer.id, type: "player" };
                            gamePhase = "block_declare";
                            subPhaseEl.textContent = "„Éñ„É≠„ÉÉ„ÇØÂÆ£Ë®Ä";
                            updateAllUI();
                            promptBlockSelection(attackingUnit, defenderPlayer, defenderPlayer); 
                            clearSelections();
                        }
                     };
                }
            }
        }
        function highlightEffectTargets(effectOwnerPlayer, opponentPlayer, targetType) {
            clearHighlights();
            if (targetType === "opponentUnit") {
                opponentPlayer.fieldUnits.forEach(unit => {
                    const el = document.querySelector(`.card[data-uuid="${unit.uuid}"][data-owner="${opponentPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
            } else if (targetType === "playerUnit") {
                 effectOwnerPlayer.fieldUnits.forEach(unit => {
                    const el = document.querySelector(`.card[data-uuid="${unit.uuid}"][data-owner="${effectOwnerPlayer.id}"]`);
                    if (el) el.classList.add('targetable');
                });
            }
        }
        function clearHighlights() {
            document.querySelectorAll('.targetable').forEach(el => el.classList.remove('targetable'));
            players.forEach(p => {
                const el = p.playerElements.lpEl.parentElement;
                if (el) {
                    el.classList.remove('targetable');
                    el.onclick = null;
                }
            });
        }
        function clearSelections() {
            const previouslySelectedCardUUID = selectedPlayerCardUUID;
            const previouslySelectedOwnerId = selectedOwnerPlayerId;
            selectedPlayerCardUUID = null;
            selectedOwnerPlayerId = null; 
            attackTargetSelected = false;
            if (previouslySelectedCardUUID && previouslySelectedOwnerId) {
                document.querySelectorAll(`.card[data-uuid="${previouslySelectedCardUUID}"][data-owner="${previouslySelectedOwnerId}"]`).forEach(el => el.classList.remove('selected-card'));
            }
            clearHighlights();
        }
        function clearEffectSelection() {
            effectTargetSelected = false;
            currentEffectAction = null;
            clearHighlights();
        }

        function promptBlockSelection(attackerUnit, attackedTarget, defenderPlayer) {
            logMessage(`${defenderPlayer.name} „ÅØ„Éñ„É≠„ÉÉ„ÇØ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ ${attackerUnit.name} „Åå ${attackedTarget.name || attackedTarget.id} „Å´ÊîªÊíÉ„ÄÇ`);
            blockInfoEl.innerHTML = `
                <p><b>${attackerUnit.name}</b> (Êîª ${attackerUnit.attack}) „Åå <b>${attackedTarget.name || attackedTarget.id}</b> „Å´ÊîªÊíÉ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
                <p>„Éñ„É≠„ÉÉ„ÇØ„Åó„Åæ„Åô„ÅãÔºü</p>
            `;
            blockerSelectionAreaEl.innerHTML = '';
            selectedBlockerUUID = null; 

            const attackerIsFlying = attackerUnit.effects.some(e => e.type === "keyword" && e.name === "È£õË°å");

            defenderPlayer.fieldUnits.forEach(unit => {
                let canBlock = true;
                if (attackedTarget.type === "unit" && attackedTarget.effects.some(e => e.type === "keyword" && e.name === "È£õË°å")) {
                    if (!unit.effects.some(e => e.type === "keyword" && e.name === "È£õË°å")) {
                        canBlock = false; 
                    }
                }
                if (attackerIsFlying && !unit.effects.some(e => e.type === "keyword" && e.name === "È£õË°å")) {
                    canBlock = false;
                }
                if (canBlock) {
                    const cardEl = createCardElement(unit, defenderPlayer.id, "blockerCandidateDisplay"); 
                    cardEl.classList.add('blocker-candidate');
                    blockerSelectionAreaEl.appendChild(cardEl);
                }
            });
            if (blockerSelectionAreaEl.children.length === 0) {
                blockerSelectionAreaEl.textContent = "„Éñ„É≠„ÉÉ„ÇØÂèØËÉΩ„Å™„É¶„Éã„ÉÉ„Éà„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ";
            }
            blockSelectModal.style.display = "flex";
        }

        function handleBlockerUnitClick(blockerCard, ownerId) {
            if (gamePhase !== "block_declare") return;
            document.querySelectorAll('#blockerSelectionArea .selected-card').forEach(el => el.classList.remove('selected-card'));
            
            if (selectedBlockerUUID === blockerCard.uuid) { 
                selectedBlockerUUID = null;
            } else {
                selectedBlockerUUID = blockerCard.uuid;
                const cardElInModal = document.querySelector(`#blockerSelectionArea .card[data-uuid="${blockerCard.uuid}"]`);
                if (cardElInModal) cardElInModal.classList.add('selected-card');
            }
        }

        function resolveCombat(attackerUnit, attackerPlayer, attackedTarget, defenderPlayer, blockerUnit) {
            attackerUnit.hasAttackedThisTurn = true;
            attackerUnit.isResting = true;

            if (blockerUnit) { 
                logMessage(`${attackerUnit.name} (Êîª${attackerUnit.attack}) vs ${blockerUnit.name} (Êîª${blockerUnit.attack}, ‰Ωì${blockerUnit.currentHealth}) „ÅÆÊà¶ÈóòÔºÅ`, true);
                
                let damageToBlocker = attackerUnit.attack;
                let damageToAttacker = blockerUnit.attack;

                const attackerHasPoison = attackerUnit.effects.some(e => e.type === "keyword" && e.name === "ÊØí");
                const blockerHasPoison = blockerUnit.effects.some(e => e.type === "keyword" && e.name === "ÊØí");

                blockerUnit.currentHealth -= damageToBlocker;
                logMessage(`${blockerUnit.name} „ÅØ ${damageToBlocker} „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åü„ÄÇ(ÊÆã„Çä‰ΩìÂäõ ${blockerUnit.currentHealth})`, true);
                
                attackerUnit.currentHealth -= damageToAttacker;
                logMessage(`${attackerUnit.name} „ÅØÂèçÊíÉ„Åß ${damageToAttacker} „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åü„ÄÇ(ÊÆã„Çä‰ΩìÂäõ ${attackerUnit.currentHealth})`, true);

                if (attackerHasPoison && damageToBlocker > 0 && blockerUnit.currentHealth > 0) {
                    logMessage(`${attackerUnit.name} „ÅÆÊØíÂäπÊûúÔºÅ ${blockerUnit.name} „ÅØÊà¶ÈóòÂæåÁ†¥Â£ä„Åï„Çå„Çã„ÄÇ`, true);
                    blockerUnit.currentHealth = 0;
                }
                if (blockerHasPoison && damageToAttacker > 0 && attackerUnit.currentHealth > 0) {
                    logMessage(`${blockerUnit.name} „ÅÆÊØíÂäπÊûúÔºÅ ${attackerUnit.name} „ÅØÊà¶ÈóòÂæåÁ†¥Â£ä„Åï„Çå„Çã„ÄÇ`, true);
                    attackerUnit.currentHealth = 0;
                }

                checkAndDestroyUnit(attackerUnit, attackerPlayer);
                checkAndDestroyUnit(blockerUnit, defenderPlayer);

            } else { 
                if (attackedTarget.type === "unit") { 
                    logMessage(`${attackerUnit.name} „Åå ${attackedTarget.name} „Å´Áõ¥Êé•ÊîªÊíÉÔºÅ`, true);
                    let damageToTarget = attackerUnit.attack;
                    const attackerHasPoison = attackerUnit.effects.some(e => e.type === "keyword" && e.name === "ÊØí");

                    attackedTarget.currentHealth -= damageToTarget;
                    logMessage(`${attackedTarget.name} „ÅØ ${damageToTarget} „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åü„ÄÇ(ÊÆã„Çä‰ΩìÂäõ ${attackedTarget.currentHealth})`, true);

                    if (attackerHasPoison && damageToTarget > 0 && attackedTarget.currentHealth > 0) {
                         logMessage(`${attackerUnit.name} „ÅÆÊØíÂäπÊûúÔºÅ ${attackedTarget.name} „ÅØÊà¶ÈóòÂæåÁ†¥Â£ä„Åï„Çå„Çã„ÄÇ`, true);
                        attackedTarget.currentHealth = 0;
                    }
                    checkAndDestroyUnit(attackedTarget, defenderPlayer); 
                     checkAndDestroyUnit(attackerUnit, attackerPlayer); 

                } else if (attackedTarget.type === "player" || attackedTarget.id === defenderPlayer.id) { 
                    logMessage(`${attackerUnit.name} „Åå ${defenderPlayer.name} „Å´Áõ¥Êé•ÊîªÊíÉÔºÅ`, true);
                    defenderPlayer.lp -= attackerUnit.attack;
                    logMessage(`${defenderPlayer.name} „ÅØ ${attackerUnit.attack} „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åü„ÄÇ(ÊÆã„ÇäLP ${defenderPlayer.lp})`, true);
                     checkAndDestroyUnit(attackerUnit, attackerPlayer); 
                }
            }
            
            updateAllUI();
            checkWinCondition();
        }

        function performAttack(attackerUUID, attackerOwnerId, targetId, targetOwnerId, targetType) {
            const attackerPlayer = players.find(p => p.id === attackerOwnerId);
            const targetEntityOwner = targetType === "player" ? players.find(p => p.id === targetId) : players.find(p => p.id === targetOwnerId);
            if (!attackerPlayer || !targetEntityOwner) { logMessage("ÊîªÊíÉ„Ç®„É©„Éº: „Éó„É¨„Ç§„É§„ÉºÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", true); clearSelections(); updateAllUI(); return; }

            const attackerUnit = attackerPlayer.fieldUnits.find(u => u.uuid === attackerUUID);
            if (!attackerUnit || attackerUnit.hasAttackedThisTurn) {
                logMessage("ÊîªÊíÉ„Ç®„É©„Éº: ÊîªÊíÉ„É¶„Éã„ÉÉ„Éà„ÅåÁÑ°Âäπ„Åã„ÄÅÊó¢„Å´ÊîªÊíÉÊ∏à„Åø„Åß„Åô„ÄÇ", true);
                clearSelections(); updateAllUI(); return;
            }
            
            let targetEntity;
            if (targetType === "unit") {
                targetEntity = targetEntityOwner.fieldUnits.find(u => u.uuid === targetId);
            } else { 
                targetEntity = targetEntityOwner; 
            }
            if (!targetEntity) { logMessage("ÊîªÊíÉ„Ç®„É©„Éº: ÊîªÊíÉÂØæË±°„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", true); clearSelections(); updateAllUI(); return; }


            logMessage(`${attackerPlayer.name} „ÅÆ ${attackerUnit.name} „Åå ${targetEntity.name || targetEntity.id} „Å´ÊîªÊíÉÂÆ£Ë®ÄÔºÅ`, true);

            const trapHolder = players.find(p => p.id !== attackerPlayer.id); 
            if (trapHolder.fieldTrap && trapHolder.fieldTrap.isSet) {
                const trap = trapHolder.fieldTrap;
                const trapEffect = trap.effects.find(e => e.type === "onOpponentAttackDeclaration");
                if (trapEffect) {
                    logMessage(`${trapHolder.name} „ÅÆ„Éà„É©„ÉÉ„Éó„Äå${trap.name}„Äç„ÅåÁô∫ÂãïÔºÅ`, true);
                    const trapTarget = trapEffect.target === "attackingUnit" ? attackerUnit : null;
                    applyEffect(trap, trapEffect, trapTarget, trapHolder);
                    
                    trapHolder.discardPile.push(trapHolder.fieldTrap);
                    trapHolder.fieldTrap = null;
                    updateAllUI(); 
                    
                    if (!attackerPlayer.fieldUnits.some(u => u.uuid === attackerUUID) || (attackerUnit && attackerUnit.currentHealth <= 0)) {
                        logMessage(`${attackerUnit.name} „ÅØ„Éà„É©„ÉÉ„Éó„Å´„Çà„ÇäÊà¶ÈóòÂâç„Å´Á†¥Â£ä„Åï„Çå„ÅüÔºÅ`, true);
                        if(attackerUnit) attackerUnit.hasAttackedThisTurn = true; 
                        clearSelections();
                        checkWinCondition();
                        changePhase("attack"); 
                        return; 
                    }
                }
            }

            currentAttackerInfo = { unit: attackerUnit, owner: attackerPlayer };
            currentAttackTargetInfo = { target: targetEntity, ownerId: targetEntityOwner.id, type: targetType };
            gamePhase = "block_declare";
            subPhaseEl.textContent = "„Éñ„É≠„ÉÉ„ÇØÂÆ£Ë®Ä";
            updateAllUI();
            promptBlockSelection(attackerUnit, targetEntity, targetEntityOwner);
            clearSelections(); 
        }


        function checkAndDestroyUnit(unit, ownerPlayer) { /* ... */ }
        function applyEffect(sourceCard, effect, targetEntity, effectOwnerPlayer) { /* ... */ }
        function findCardByUUID(uuid) { /* ... */ }
        function checkWinCondition() { /* ... */ }
        // (checkAndDestroyUnit, applyEffect, findCardByUUID, checkWinCondition „ÅØÂâçÂõû„Å®Âêå„Åò)
        function checkAndDestroyUnit(unit, ownerPlayer) {
            if (unit.currentHealth <= 0) {
                logMessage(`${unit.name} „ÅØÁ†¥Â£ä„Åï„Çå„Åü„ÄÇ`, true);
                ownerPlayer.fieldUnits = ownerPlayer.fieldUnits.filter(u => u.uuid !== unit.uuid);
                ownerPlayer.discardPile.push(unit);
                const onDestroyedEffect = unit.effects.find(e => e.type === "onDestroyed");
                if (onDestroyedEffect) {
                    applyEffect(unit, onDestroyedEffect, null, ownerPlayer);
                }
            }
        }
        function applyEffect(sourceCard, effect, targetEntity, effectOwnerPlayer) {
            logMessage(`ÂäπÊûúÁô∫Âãï: ${sourceCard.name} „ÅÆ ${effect.action} (ÂØæË±°: ${targetEntity ? targetEntity.name || targetEntity.id : '„Å™„Åó'}, Áô∫ÂãïËÄÖ: ${effectOwnerPlayer.name})`, true);
            let actualTargetPlayer;
            switch (effect.action) {
                case "draw":
                    for (let i = 0; i < effect.value; i++) { drawCard(effectOwnerPlayer); }
                    break;
                case "addCore":
                    effectOwnerPlayer.core = Math.min(MAX_CORE, effectOwnerPlayer.core + effect.value);
                    logMessage(`${effectOwnerPlayer.name} „ÅØÂäπÊûú„Åß ${effect.value} „Ç≥„Ç¢Áç≤Âæó„ÄÇ`, true);
                    break;
                case "damageUnit":
                    if (targetEntity && targetEntity.type === "unit") {
                        targetEntity.currentHealth -= effect.value;
                        logMessage(`${targetEntity.name} „ÅØÂäπÊûú„Åß ${effect.value} „ÉÄ„É°„Éº„Ç∏„ÄÇÊÆã„Çä‰ΩìÂäõ ${targetEntity.currentHealth}`, true);
                        const targetOwner = players.find(p => p.fieldUnits.some(u => u.uuid === targetEntity.uuid));
                        if (targetOwner) { checkAndDestroyUnit(targetEntity, targetOwner); }
                    } else { logMessage(`ÂäπÊûúÂØæË±°„ÅÆ„É¶„Éã„ÉÉ„Éà„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ(${effect.action})`, true); }
                    break;
                case "damagePlayer":
                    actualTargetPlayer = (effect.target === "opponentPlayer") ? players.find(p => p.id !== effectOwnerPlayer.id) : effectOwnerPlayer;
                    if (actualTargetPlayer) {
                        actualTargetPlayer.lp -= effect.value;
                        logMessage(`${actualTargetPlayer.name} „ÅØÂäπÊûú„Åß ${effect.value} „ÉÄ„É°„Éº„Ç∏„ÄÇÊÆã„ÇäLP ${actualTargetPlayer.lp}`, true);
                    }
                    break;
                case "healPlayer":
                    actualTargetPlayer = (effect.target === "self" || effect.target === "player") ? effectOwnerPlayer : players.find(p => p.id !== effectOwnerPlayer.id);
                    if (actualTargetPlayer) {
                        actualTargetPlayer.lp += effect.value;
                        logMessage(`${actualTargetPlayer.name} „ÅØÂäπÊûú„Åß ${effect.value} LPÂõûÂæ©„ÄÇÊÆã„ÇäLP ${actualTargetPlayer.lp}`, true);
                    }
                    break;
                case "destroyUnit":
                     if (targetEntity && targetEntity.type === "unit") {
                        logMessage(`${targetEntity.name} „ÅØÂäπÊûú„Äå${sourceCard.name}„Äç„ÅßÁ†¥Â£ä„Åï„Çå„Åü„ÄÇ`, true);
                        targetEntity.currentHealth = 0;
                        const targetOwner = players.find(p => p.fieldUnits.some(u => u.uuid === targetEntity.uuid));
                        if (targetOwner) { checkAndDestroyUnit(targetEntity, targetOwner); }
                    } else if (targetEntity && targetEntity.type === "trap" ) {
                        const trapOwner = players.find(p => p.fieldTrap && p.fieldTrap.uuid === targetEntity.uuid);
                        if (trapOwner) {
                            trapOwner.discardPile.push(trapOwner.fieldTrap);
                            trapOwner.fieldTrap = null;
                            logMessage(`„Çª„ÉÉ„Éà„Åï„Çå„Å¶„ÅÑ„Åü ${targetEntity.name} „ÅØÂäπÊûú„Äå${sourceCard.name}„Äç„ÅßÁ†¥Â£ä„Åï„Çå„Åü„ÄÇ`, true);
                        }
                    } else { logMessage(`ÂäπÊûúÂØæË±°„ÅÆ„É¶„Éã„ÉÉ„Éà„Åæ„Åü„ÅØ„Éà„É©„ÉÉ„Éó„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ(${effect.action})`, true); }
                    break;
            }
            updateAllUI(); checkWinCondition();
        }
        function findCardByUUID(uuid) {
            for (const player of players) {
                const cardInHand = player.hand.find(c => c.uuid === uuid); if (cardInHand) return cardInHand;
                const cardOnField = player.fieldUnits.find(c => c.uuid === uuid); if (cardOnField) return cardOnField;
                if (player.fieldTrap && player.fieldTrap.uuid === uuid) return player.fieldTrap;
                if (player.fieldResource && player.fieldResource.uuid === uuid) return player.fieldResource;
            }
            return null;
        }
        function checkWinCondition() {
            const player1 = players[0];
            const player2 = players[1];
            let winner = null;
            if (player1.lp <= 0 && player2.lp <= 0) {
                logMessage("Âºï„ÅçÂàÜ„ÅëÔºÅ‰∏°„Éó„É¨„Ç§„É§„Éº„ÅÆLP„Åå0‰ª•‰∏ã„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ", true); winner = "draw";
            } else if (player1.lp <= 0) {
                logMessage(`${player2.name} „ÅÆÂãùÂà©ÔºÅ (${player1.name} „ÅÆLP„Åå0)`, true); winner = player2;
            } else if (player2.lp <= 0) {
                logMessage(`${player1.name} „ÅÆÂãùÂà©ÔºÅ (${player2.name} „ÅÆLP„Åå0)`, true); winner = player1;
            }
            if (winner && gamePhase !== "gameOver") {
                gamePhase = "gameOver";
                if (winner === "draw") { showMessage("Âºï„ÅçÂàÜ„ÅëÔºÅ"); }
                else { showMessage(`${winner.name} „ÅÆÂãùÂà©ÔºÅ`); }
                updateAllUI();
                return true;
            }
            return false;
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initGame();
        });
    </script>
</body>
</html>
